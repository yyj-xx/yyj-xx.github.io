<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>标签：学习 - Jay的个人博客</title>
    <meta charset="UTF-8">
    <meta name="description" content="记录分享学习">
    <meta name="keywords" content="记录,学习,分享">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/assets/logoko.png" type="image/png" />
    <meta name="description" content="记录分享学习">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay的个人博客">
<meta property="og:url" content="https://yyj-xx.github.io/tags/%E5%AD%A6%E4%B9%A0/page/2/index.html">
<meta property="og:site_name" content="Jay的个人博客">
<meta property="og:description" content="记录分享学习">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jay jay">
<meta property="article:tag" content="记录,学习,分享">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1679977717833">
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1679977717833">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/assets/background.gif)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Jay jay" class="mdui-btn mdui-btn-icon"><img src="/assets/avatar.jpg" alt="Jay jay"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Jay jay">
            <img src="/assets/avatar.jpg" alt="Jay jay" alt="Jay jay">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>20</div>
        <div><span>标签</span>2</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://www.baidu.com/s?wd=" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/436182677" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/yyj-xx/yyj-xx.github.io" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">学习</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E5%86%99%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">学习写博客</a>
    </div>
    
  </div>

    
    

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2023 Jay jay
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br>人生需要不断的探索
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="python学习之模块、包、库的使用" class="lazyload">
                    <h1>python学习之模块、包、库的使用</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年10月17日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 16 分钟</a>
        </div>

        <article>
            
                <h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在python中一个模块（module）是一个以.py结尾的python文件，包含了python对象和语句。</p>
<p>模块的好处：</p>
<ol>
<li>方便组织代码</li>
<li>提高代码的重用性</li>
<li>增加代码的重用性</li>
<li>避免函数名和变量名冲突</li>
</ol>
<p>模块的导入方式：</p>
<ul>
<li><p>模块就是.py类型的Python文件</p>
</li>
<li><p>导入时不需要.py后缀，直接导入文件名即可</p>
<p>1、**利用<code>import</code>**直接导入：</p>
</li>
<li><p>语法：**<code>import</code>** module_name</p>
</li>
<li><p>使用方式：module_name.class_name或者module.func_name</p>
<p>2、利用**<code>import</code>**导入模块并设置一个别名</p>
</li>
<li><p>语法：**<code>import</code>** module_name <strong><code>as</code></strong> XXX</p>
</li>
<li><p>使用方式：XXX.class_name或者XXX.funct_name</p>
<p>3、借助**<code>from</code>**复制模块的属性，可以实现只导入模块中的部分类或函数或变量</p>
</li>
<li><p>语法：**<code>from</code>** module_name <strong><code>import</code></strong> class_name， funct_name</p>
</li>
<li><p>使用方式：直接调用函数或实例化类即可</p>
</li>
<li><p>但要注意，from把变量从模块中导入后，会导致<strong>相同名称的变量被覆盖</strong>，也就是说不同模块的命名空间会在此处重叠。</p>
<p>4、借助**<code>from...import</code> ***导入模块全部内容</p>
</li>
<li><p>语法：**<code>from</code>** module_name <strong><code>import</code> *</strong></p>
</li>
<li><p>使用时直接调用函数或实例化类即可</p>
<p>5、借助importlib模块实现导入以数字开头的模块</p>
</li>
<li><p>语法：**<code>import importlib</code>**</p>
</li>
<li><p>XXX = <strong><code>importlib.import_module</code></strong>(“module_name”)</p>
</li>
<li><p>使用时XXX.class_name或者XXX.func_name</p>
</li>
</ul>
<h2 id="自带模块："><a href="#自带模块：" class="headerlink" title="自带模块："></a>自带模块：</h2><h3 id="Turtle模块："><a href="#Turtle模块：" class="headerlink" title="Turtle模块："></a>Turtle模块：</h3><p>Turtle是python内嵌的绘制线、圆及其他形状（包括文本）的图形模块，它可以创建一个画笔，在一个横轴为x纵轴为y的坐标系原点位置开始，根据一组函数指令控制，在这个平面绘制图形</p>
<p>画布（Canvas）:是Turple模块展开用于绘制图形的区域，默认一个坐标原点为画布中心的坐标轴，可以使用turtle.screensize(width,height,bg(bg代表背景颜色))和turtle.setup设置它的大小和初始位置</p>
<p>turtle.setup(width,height,startx,starty)其中startx，starty是画布左上角顶点在窗口的坐标位置</p>
<p>画笔:</p>
<p>画笔状态：使用位置方向描述画笔状态</p>
<p>画笔属性：包括画笔颜色、宽度移动速度，</p>
<p>​                turtle.pencolor(color)、turtle.pensize(width)、 tu                                                                                                           rtle.speed(speed)</p>
<p>绘图命令：</p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/4.jpg"></p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/5.jpg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Turtle模块：</span><br><span class="hljs-keyword">import</span> turtle<br><span class="hljs-comment">#绘制一个圆和一个填充正方形</span><br>turtle.penup()<br>turtle.goto(-<span class="hljs-number">150</span>,<span class="hljs-number">0</span>)<br>turtle.pendown()<br>turtle.pencolor(<span class="hljs-string">&#x27;blue&#x27;</span>)<br>turtle.begin_fill()<br>turtle.fillcolor(<span class="hljs-string">&#x27;blue&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    turtle.forward(<span class="hljs-number">100</span>)<br>    turtle.left(<span class="hljs-number">90</span>)<br>turtle.end_fill()<br><span class="hljs-comment">#画圆</span><br>turtle.penup()<br>turtle.goto(<span class="hljs-number">100</span>,<span class="hljs-number">0</span>)<br>turtle.pendown()<br>turtle.color(<span class="hljs-string">&#x27;red&#x27;</span>)<br>turtle.pensize(<span class="hljs-number">3</span>)<br>turtle.circle(<span class="hljs-number">50</span>)<br>turtle.done()<br><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/6.jpg"></p>
<p>用turtle在画布上写字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#在画布上写文字</span><br>t=turtle.Turtle()<br>t.penup()<br>t.goto(-<span class="hljs-number">80</span>,<span class="hljs-number">20</span>)<br>t.write(<span class="hljs-string">&quot;望庐山瀑布&quot;</span>,font=(<span class="hljs-string">&quot;黑体&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;normal&quot;</span>))<br>t.sety(-<span class="hljs-number">10</span>) <span class="hljs-comment">#画笔向下移</span><br>t.write(<span class="hljs-string">&quot;你很牛&quot;</span>,font=(<span class="hljs-string">&quot;宋体&quot;</span>,<span class="hljs-number">16</span>,<span class="hljs-string">&quot;normal&quot;</span>))<br>t.hideturtle()<br>turtle.done()<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/7.jpg"></p>
<h3 id="Random模块："><a href="#Random模块：" class="headerlink" title="Random模块："></a>Random模块：</h3><p>random模块用于生成随机数：</p>
<ol>
<li><p>random.random()函数用于生成[0，1）之间的随机浮点数。</p>
</li>
<li><p>random.uniform(start，end)函数用于生成一个指定范围内的随机浮点数</p>
</li>
<li><p>random.randint(start，end)函数用于生成一个指定范围内的整数</p>
</li>
<li><p>random.randrange(start，end，step)函数用于生成指定范围指定步长的随机整数</p>
</li>
<li><p>random.choice(序列对象)函数的功能是从序列对象中获取一个随机元素</p>
</li>
<li><p>random.shuffle(序列对象[,random])函数用于将一个序列对象中的元素打乱</p>
</li>
<li><p>random.sample(序列对象，k)从指定序列对象中随机获取指定长度（k）的片的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#random模块</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br>   <span class="hljs-built_in">print</span>(random.random())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">10</span>)<br>random.uniform(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)<br>random.uniform(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>)<br>random.uniform(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>))<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">10</span>)<br>list1=[]<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>    list1.append(random.randrange(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(list1)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>):<br>    <span class="hljs-built_in">print</span>(random.choice(list1))<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>):<br>    <span class="hljs-built_in">print</span>(random.shuffle(list1))<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br>list2=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>slice1=random.sample(list2,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;slice1:&quot;</span>,slice1)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/8.jpg"></p>
</li>
</ol>
<h3 id="Time和Datetime模块："><a href="#Time和Datetime模块：" class="headerlink" title="Time和Datetime模块："></a>Time和Datetime模块：</h3><p>time模块主要用于时间访问和转换提供了各种相关函数：</p>
<ol>
<li>time.time():返回时间戳（自1970-1-1 0：00：00至今所经历的浮点秒数）</li>
<li>time.asctime([t]):将一个tuple或struct_time形式的时间转换为一个表示当前本地时间的字符串</li>
<li>time.ctime([secs]):将一个秒数时间戳表示的时间转换为一个表示当地时间的字符串</li>
<li>time.localtime([secs]):返回以指定时间戳对应的本地时间struct——time对象</li>
<li>time.strftime(s,t):将struct_time对象转换成字符串</li>
<li>time.altzone：返回与utc时间的时间差以秒为单位</li>
</ol>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/9.jpg"></p>
<p>datetime模块为日期和事件处理同时提供了简单复杂的方法，其中有</p>
<p>日期类（date类）：d=datetime.date(year,mouth,day)</p>
<p>时间类（time类）:t=time(hour,[minute,[second,[,tzinfo]]])</p>
<p>日期时间类(datetime类):dt=datetime(year,month,day,hout,minute,second,microsecond,tzinfo)</p>
<p>时间差类（timedelta类):td=datetime.timedelta(days,seconds,microseconds,milliseconds,hours,weeks)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#datetime类的使用：</span><br><span class="hljs-comment">#date类：</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date<br>d=date.today()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前日期：&quot;</span>,d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;日期：&#123;&#125;年&#123;&#125;月&#123;&#125;日&quot;</span>.<span class="hljs-built_in">format</span>(d.year,d.month,d.day))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;今天是周&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(d.isoweekday()))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br><span class="hljs-comment">#time类：</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;时间最大值：&quot;</span>,time.<span class="hljs-built_in">max</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;时间最小值：&quot;</span>,time.<span class="hljs-built_in">min</span>)<br>t=time(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">8888</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;时间：&#123;&#125;时&#123;&#125;分&#123;&#125;秒&#123;&#125;微妙&quot;</span>.<span class="hljs-built_in">format</span>(t.hour,t.minute,t.second,t.microsecond))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br><span class="hljs-comment">#datetime类</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>dt=datetime.now()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前日期：&quot;</span>,dt.date())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前时间：&#123;&#125;  当前年份：&#123;&#125;年  当前月份：&#123;&#125;月   当前日期：&#123;&#125;日&quot;</span>.<span class="hljs-built_in">format</span>(dt.time(),dt.year,dt.month,dt.day))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;时间：&quot;</span>,datetime(<span class="hljs-number">2018</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">12</span>,<span class="hljs-number">20</span>,<span class="hljs-number">36</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br><span class="hljs-comment">#timedelta类</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime,timedelta<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1周包含的秒数：&quot;</span>,timedelta(days=<span class="hljs-number">7</span>).total_seconds())<br>d=datetime.now()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前本地系统时间:&quot;</span>,d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一天后：&quot;</span>,d+timedelta(days=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一天前：&quot;</span>,d+timedelta(days=-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/10.jpg"></p>
<h3 id="OS模块："><a href="#OS模块：" class="headerlink" title="OS模块："></a>OS模块：</h3><p>​    os模块是一个用于访问操作系统功能的模块，通过os模块中提供的接口可以实现以下功能：</p>
<ol>
<li><p>获取平台信息</p>
<ul>
<li>os.getcwd():获取当前工作目录</li>
<li>os.sep:查看操作系统特定的路径分隔符</li>
<li>os.linesep:查看当前平台使用的行终结符</li>
<li>os.pathsep:查看用于分隔文件路径的字符串</li>
<li>os.name:查看当前系统平台</li>
<li>os.environ:查看当前系统的环境变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分隔符：&quot;</span>,os.sep)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;操作系统平台：&quot;</span>,os.name)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;环境变量path：&quot;</span>,os.getenv(<span class="hljs-string">&#x27;path&#x27;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/11.jpg"></p>
</li>
<li><p>目录文件操作：</p>
<ul>
<li><p>os.mkdir(newdir):创建新目录</p>
</li>
<li><p>os.rmdir(dir):删除目录</p>
</li>
<li><p>os.listdir(path):列出指定目录path下所有文件</p>
</li>
<li><p>os.chdir(path)：改变当前脚本的工作目录为指定路径path</p>
</li>
<li><p>os.remove(file)：删除一个指定文件file</p>
</li>
<li><p>os.rename(oldname,newname):重命名一个文件</p>
<p>os模块获取文件属性：</p>
</li>
<li><p>os.path.abspath(path):返回绝对路径</p>
</li>
<li><p>os.path.split(path):将path分割成包含目录和文件名的元组返回</p>
</li>
<li><p>os.path.exists(path):如果path存在则返回true否则返回false</p>
</li>
<li><p>os.path.isfile(file):如果file是一个存在的文件则返回true否则返回false</p>
</li>
<li><p>os.path.isdir(dir)：如果dir是一个存在的目录则返回true否则返回false、</p>
</li>
<li><p>os.path.getsize(file);返回指定文件大小</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#os文件操作：</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前工作路径：&quot;</span>,os.getcwd())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前路径的目录和文件列表：&quot;</span>,os.listdir())<br>os.rename(<span class="hljs-string">&quot;1.py&quot;</span>,<span class="hljs-string">&quot;11.py&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;重命名文件夹后当前路径的目录和文件列表&quot;</span>,os.listdir())<br>os.mkdir(<span class="hljs-string">&quot;newDir&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;创建文件目录后当前目录和文件列表：&quot;</span>,os.listdir())<br>os.chdir(<span class="hljs-string">&quot;newDir&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;改变当前工作路径后，当前工作路径：&quot;</span>,os.getcwd())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(路径，文件)&quot;</span>,os.path.split(<span class="hljs-string">r&quot;d:\OS模块\1.py&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目录存在？：&quot;</span>,os.path.exists(<span class="hljs-string">r&quot;d:\OS模块&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件存在？&quot;</span>,os.path.isfile(<span class="hljs-string">r&quot;d:\OS模块\1.py&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件大小：&quot;</span>,os.path.getsize(<span class="hljs-string">r&quot;d:\OS模块\1.py&quot;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/12.jpg"></p>
</li>
<li><p>调用系统命令：</p>
<p>os模块中用于调用系统命令的常用函数：</p>
<ul>
<li><p>os.popen(cmd[,mode[,bufsize]]):用于由一个命令打开一个管道。cmd为系统命令，mode为模式（r或w），bufsize为文件需要的缓冲大小</p>
</li>
<li><p>os.sysem(shell):运行shell命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.system(<span class="hljs-string">&quot;rmdir d:\\python学习\\大四学习\\newDir&quot;</span>)<br>os.popen(<span class="hljs-string">r&quot;c:\windows\notepad.exe&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序执行成功&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/13.jpg"></p>
</li>
</ul>
</li>
</ol>
<h2 id="Sys模块："><a href="#Sys模块：" class="headerlink" title="Sys模块："></a>Sys模块：</h2><p>sys模块提供对python解释器相关的操作</p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/14.jpg"></p>
<h3 id="Timeit模块："><a href="#Timeit模块：" class="headerlink" title="Timeit模块："></a>Timeit模块：</h3><p>是一个计时功能的模块，用于测试一段代码运行时间 </p>
<p>timeit()函数返回执行代码所用的时间单位为秒：t=timeit(stmt=’code’,setup=’code’,timer=<defaulttimer>,number=n),stmt是要执行的代码，setup为执行代码的准备工作，timer一般为time.clock(),number为执行代码次数</defaulttimer></p>
<p>repeat()函数比timeit函数多了一个repeat参数控制执行多少遍格式：</p>
<p>t=repeat(stmt=’code’,setup=’code’,timer=<defaulttimer>,repeat=m,number=n)</defaulttimer></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> timeit<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfun</span>():</span><br>    <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):<br>            <span class="hljs-built_in">sum</span>=<span class="hljs-built_in">sum</span>+i+j<br><br>t1=timeit.timeit(stmt=myfun,number=<span class="hljs-number">1000</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;t1=&quot;</span>,t1)<br>t2=timeit.repeat(stmt=myfun,repeat=<span class="hljs-number">6</span>,number=<span class="hljs-number">1000</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;t2=&quot;</span>,t2)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/15.jpg"></p>
<h3 id="Zlib模块："><a href="#Zlib模块：" class="headerlink" title="Zlib模块："></a>Zlib模块：</h3><p>用来进行数据打包解包常用函数如下：</p>
<ol>
<li><p>zlib.compress(string):对string进行压缩</p>
</li>
<li><p>zlib.decompress(string):对string进行解压</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用zlib模块对字符串进行压缩解压</span><br><span class="hljs-keyword">import</span> zlib<br><span class="hljs-built_in">str</span>=<span class="hljs-string">b&#x27;贾程林是个猪头，大猪头&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;压缩前：&#123;&#125;字符个数：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)))<br>str_com=zlib.compress(<span class="hljs-built_in">str</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;压缩后：&#123;&#125;字符个数：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(str_com,<span class="hljs-built_in">len</span>(str_com)))<br>str_dec=zlib.decompress(str_com)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;解压后：&#123;&#125;字符个数：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(str_dec,<span class="hljs-built_in">len</span>(str_dec)))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/16.jpg"></p>
</li>
</ol>
<p>模块的使用简单总结就是将模块导入，知道模块中函数的功能与传递参数的含义熟练的使用就可以掌握。</p>
<h2 id="第三方库模块："><a href="#第三方库模块：" class="headerlink" title="第三方库模块："></a>第三方库模块：</h2><h3 id="Pyinstaller库"><a href="#Pyinstaller库" class="headerlink" title="Pyinstaller库:"></a>Pyinstaller库:</h3><p>可以用这个库来打包程python应用程序，打包时pyinstaller库会扫描python程序的所有文档，分析所有代码找出代码运行所需的模块，然后将所有这些模块和代码放在一个文件夹里或一个可执行文件里这样用户不需要下载各种软件运行环境就可以执行这个可执行程序</p>
<p>下载和安装：</p>
<p>pip install pyinstaller</p>
<p>打包应用程序：</p>
<ol>
<li>创建一个python源文件</li>
<li>打开命令行界面进入源文件所在路径</li>
<li>在命令行界面运行命令：”pyinstaller -F  源文件名“ 打包源文件，成功执行后生成可执行文件源文件名.exe在源文件所在路径的dist中就可以让别人使用</li>
</ol>
<p>第三方库模块还有Numpy库开源的数值计算库、Pandas库一种解决数据分析任务的工具库、SciPy库一款方便易于使用专为科学和工程设计的库、Matplotlib库一个基于python跨平台交互式2D绘图库Jieba库优秀的中文分词库这些库的需要参考使用文档学会调用其内部函数就可以了。</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>为了对同一类型的模块进行有效的管理，引入了包（package）来组织模块，包是模块所在文件的目录，并且在该目录下必须有一个名为__init__.py的文件；否则python就将该目录视作为普通目录，而不是一个包。__init__.py可以是一个空文件，也可以包含python代码。</p>
<p>包的导入：</p>
<p>​    1.利用**<code>import</code><strong>直接导入包（</strong>仅仅导入__init__.py中的内容**）</p>
<ul>
<li><p>语法：import package_name</p>
</li>
<li><p>直接导入一个包，仅仅可以使用_<em>init</em>_.py中的全部内容</p>
</li>
<li><p>使用：package_name.func_name 或者 package_name.class</p>
<p>2.导入包中的某一个模块</p>
</li>
<li><p>语法：<code>import</code> package_name.module_name</p>
</li>
<li><p>使用：package_name.module_na112afme.func_name或<br>package_name.module_name.class_name</p>
</li>
</ul>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><p>具有相关功能的包和模块集合则形成了库如：python标准库、numpy库等</p>
<p>按照库的来源可分为三种库：</p>
<ol>
<li><p>标准库（python自带）</p>
<p>常用标准库：</p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/1.jpg"></p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/2.jpg"></p>
</li>
<li><p>第三方库（由第三方机构发布具有特定功能）</p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/3.jpg"></p>
<p>第三方库的使用和自带的库使用类似不过首先需要在terminal中用pip安装相关库然后导入库和模块按照模块使用方法使用即可</p>
</li>
<li><p>自定义库（用户创建）</p>
<p>用户自己可以编写具有特定功能的模块，保存到扩展名为.py的文件中。由用户自己编写的模块称为自定义模块。和标准库模块第三方库中的模块一样。如果要调用自定义模块中的类、函数、属性也必须用import语句导入后在使用</p>
<p>以一个项目名称为P1的例子介绍自定义模块创建和使用：</p>
<ul>
<li><p>场景1：</p>
<p>在源文件A11.py中调用包package1中的模块A12：</p>
<p>实现步骤：</p>
<ol>
<li>在package1下添加A11.py和模块A12中的程序代码</li>
<li>分别编写源文件A11.py和A2中的程序代码</li>
</ol>
<p>目录结构如下：</p>
<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/17.jpg"></p>
<p>方法一：源文件A11.py中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> A12<br><span class="hljs-built_in">print</span>(A12.func_A12()) <span class="hljs-comment">#使用A12中的函数func_A12()</span><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/18.jpg" alt="结果" class="lazyload"></p>
<p>方法二：源文件A11中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法二</span><br><span class="hljs-keyword">from</span> A12 <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(func_A12())<span class="hljs-comment">#使用A12中的函数func_A12()</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/19.jpg"></p>
<p>方法三：源文件A11中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法三：</span><br><span class="hljs-keyword">from</span> A12 <span class="hljs-keyword">import</span> func_A12<br><span class="hljs-built_in">print</span>(func_A12())<span class="hljs-comment">#使用A12中的函数func_A12()</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/20.jpg"></p>
<p>方法四：源文件A11中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法四</span><br><span class="hljs-keyword">import</span> A12 <span class="hljs-keyword">as</span> a<br><span class="hljs-built_in">print</span>(a.func_A12())<span class="hljs-comment">#使用A12中的函数func_A12()</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/21.jpg"></p>
</li>
<li><p>场景二：在源文件main.py中调用包pack2中的模块A2</p>
<p>实现步骤：</p>
<ol>
<li>在pack2文件夹中创建__init__.py</li>
<li>分别编写模块A2和源文件main.py中的程序代码</li>
</ol>
<p>方法一：</p>
<p>源文件main.py中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法一：</span><br><span class="hljs-keyword">from</span> pack2.A2 <span class="hljs-keyword">import</span> *<span class="hljs-comment">#或者from pack2.A2 import func_A2()</span><br><span class="hljs-built_in">print</span>(func_A2())<span class="hljs-comment">#调用函数</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/22.jpg"></p>
<p>方法二：</p>
<p>源文件main.py中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法2</span><br><span class="hljs-keyword">import</span> pack2.A2<br><span class="hljs-built_in">print</span>(pack2.A2.func_A2())<span class="hljs-comment">#调用函数</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/23.jpg"></p>
</li>
<li><p>场景三：在源文件A11中调用模块A2</p>
<p>在本场景中源文件A11.py和模块A2分别在两个不同路径的包中实现步骤：</p>
<ol>
<li>在pack2中添加__init__.py</li>
<li>分别编写源文件A11和模块A2</li>
</ol>
</li>
</ul>
<p>方法一：</p>
<p>源文件A11中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方法一：</span><br><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;d:\\python学习\\大四学习\\pack\\pack2&#x27;</span>)<span class="hljs-comment">#引入pack2所在路径</span><br><span class="hljs-keyword">import</span> A12  <span class="hljs-comment">#导入模块</span><br><span class="hljs-built_in">print</span>(A12.func_A12())   <span class="hljs-comment">#调用函数</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/24.jpg"></p>
<p>方法二：</p>
<p>源文件A11中的程序代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法2：</span><br><span class="hljs-keyword">import</span> sys<br><br>sys.path.append(<span class="hljs-string">&#x27;d:\\python学习\\大四学习\\pack&#x27;</span>)  <span class="hljs-comment"># 引入pack所在路径</span><br><span class="hljs-keyword">import</span> pack2.A2<br><span class="hljs-built_in">print</span>(pack2.A2.func_A2())<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/17/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%81%E5%8C%85%E3%80%81%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/25.jpg"></p>
</li>
</ol>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="python学习三面向对象的程序设计" class="lazyload">
                    <h1>python学习三面向对象的程序设计</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年10月08日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.2k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 14 分钟</a>
        </div>

        <article>
            
                <h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="两种程序设计方式："><a href="#两种程序设计方式：" class="headerlink" title="两种程序设计方式："></a>两种程序设计方式：</h2><ul>
<li>面向过程程序设计（POP）：把计算机程序视为一系列集合即一组函数按事先顺序执行，函数为基本单位。</li>
<li>面向对象程序设计（OOP）：把计算机程序视为一组对象的集合，每个对象可以接受其他对象发送的消息，程序的执行指的是消息在各个对象之间的传递，对象是基本单位。</li>
</ul>
<p>python支持POP、OOP。</p>
<p><strong>OOP：</strong>基本思想将数据以及对数据的操作封装在一起组成一个相互依存不可分割的整体，及对象。对相同，类型的对象进行分类、抽象后得出共同特征而形成类。基本概念包括对象、类、消息、<strong>封装、继承和多态</strong>。</p>
<p>对象是要研究的任何事物，类是一组具有相同特征和相同操作对象的定义，一个类所包含的数据和方法描述一组对象的共同特征和行为。不同类之间可以有继承关联依赖等关系。</p>
<p>消息：消息是一个对象要求另一个对象实施某项操作的请求。</p>
<h2 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h2><p>类是一种类型，对象是该类型的一个变量，类是抽象的，一般不占用内存空间，对象是具体的，创建对象时系统会为其分配相应的内存空间。</p>
<p>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名：</span><br><span class="hljs-class">	&quot;&quot;&quot;类说明&quot;&quot;&quot;</span><br><span class="hljs-class">    类体			包含数据成员（成员）成员方法（行为）</span><br></code></pre></td></tr></table></figure>

<h2 id="对象创建和使用"><a href="#对象创建和使用" class="headerlink" title="对象创建和使用"></a>对象创建和使用</h2><p>格式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">对象名=类名([参数列表])<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<p>对象.成员        对象.方法()  </p>
<h2 id="类的成员："><a href="#类的成员：" class="headerlink" title="类的成员："></a>类的成员：</h2><h3 id="成员类型："><a href="#成员类型：" class="headerlink" title="成员类型："></a>成员类型：</h3><h4 id="按照访问权限分类："><a href="#按照访问权限分类：" class="headerlink" title="按照访问权限分类："></a>按照访问权限分类：</h4><ol>
<li><p>公有成员：（类内外均可访问）</p>
<p>不以下划线开头</p>
</li>
<li><p>私有成员：</p>
<p>以单下划线或双下划线开头</p>
<ul>
<li>单下划线开头的私有成员：类和派生类可以访问这些成员，在类外不建议直接访问</li>
<li>双下划线开头的私有成员（但不能以两个或更多下划线结束）：只有类自己可以访问，派生类不能访问</li>
</ul>
</li>
</ol>
<h4 id="按照属于类还是属于对象分类："><a href="#按照属于类还是属于对象分类：" class="headerlink" title="按照属于类还是属于对象分类："></a>按照属于类还是属于对象分类：</h4><ol>
<li>类成员：定义在类体中且在所有方法外的成员为类成员，类成员属于类本身，一般通过类名调用，不建议使用对象名调用。</li>
<li>实例成员：在类的方法中定义的成员为实例成员。实例成员只能被对象调用，实例成员一般在构造方法”_<em>init_</em>()”中创建，或在其他方法中创建</li>
</ol>
<h4 id="对类成员访问："><a href="#对类成员访问：" class="headerlink" title="对类成员访问："></a>对类成员访问：</h4><ol>
<li><p>公有的类成员：在类的方法中通”类名.类成员”或”self.类成员”访问，在类外通过”类名.类成员”或“对象名.类成员”访问。</p>
</li>
<li><p>公有的实例成员：在类的方法中通过“self.实例成员”访问，在类外通过“对象名.实例成员”访问</p>
</li>
<li><p>私有的类成员：在类的方法中通过”类名.类成员“或”self.类成员”访问。在类外面不能直接访问</p>
</li>
<li><p>私有的实力成员：在类方法中通过“self.实力成员”访问，在类外不能直接访问。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>当用对象名调用类成员时“对象名.类成员名”只是“类.类成员”的一份拷贝，修改“对象名.类成员名”不会修改“类.类成员”。</li>
<li>当类成员和实例成员名同名时，在类的方法中和外面，“类名.类成员”调用的是同名的类成员，“self.实例成员”（在类方法中）或“对象名.实例成员”（在类的外面）调用的是同名的实例成员。</li>
<li>定义在类的方法中，且不以self为前缀的变量是该方法的局部变量，不能在方法外使用。</li>
</ol>
<p><strong>例子：</strong>定义一个Women类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name,sex,age</span>):</span><br>        self.name=name<br>        self._sex=sex<br>        self.__age=age<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getAge</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__age<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    w=Woman(<span class="hljs-string">&quot;小贾&quot;</span>,<span class="hljs-string">&quot;Female&quot;</span>,<span class="hljs-number">18</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;姓名：%s,性别：%s,年龄：%d.&quot;</span>%(w.name,w._sex,w.getAge()))<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.jpg" alt="结果" class="lazyload"></p>
<p>例2：类成员和实例成员的创建和使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span><br>    chinese=<span class="hljs-number">142</span>	<span class="hljs-comment">#类成员</span><br>    maths=<span class="hljs-number">1</span><br>    english=<span class="hljs-number">141</span><br>    <span class="hljs-comment">#定义构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span> <br>        self.name=name	<span class="hljs-comment">#实例成员</span><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s1=Student(<span class="hljs-string">&quot;加魔&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;的语文成绩&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(s1.name,<span class="hljs-built_in">str</span>(Student.chinese)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;的数学成绩&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(s1.name, <span class="hljs-built_in">str</span>(Student.maths)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;的英语成绩&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(s1.name, <span class="hljs-built_in">str</span>(Student.english)))<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.jpg" alt="结果" class="lazyload"></p>
<p><strong>内置成员：</strong></p>
<p>所有的类（无论是系统内置的类还是自定义的类）都有一组特殊的成员，其前后各有两个下划线时类的内置成员：</p>
<ol>
<li>__name__:类的名字，用字符串表示</li>
<li>__doc__：类的文档字符串</li>
<li>__bases__:由所有父类组成的元组</li>
<li>__dict__:由类的成员组成的字典</li>
<li>__module__:类所属模块</li>
</ol>
<p>查看异常类Exception的内置成员：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类的名字:&quot;</span>,Exception.__name__)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类的父类:&quot;</span>,Exception.__bases__)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类的文档:&quot;</span>,Exception.__doc__)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类的成员:&quot;</span>,Exception.__dict__)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类所属模块:&quot;</span>,Exception.__module__)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.jpg" alt="结果" class="lazyload"></p>
<h2 id="类的方法："><a href="#类的方法：" class="headerlink" title="类的方法："></a>类的方法：</h2><ol>
<li><p>公有方法：公有方法的名字不以下划线开头，可以在类的外面通过类名或对象名调用</p>
</li>
<li><p>私有方法：私有方法以两个或更多下划线开头，可以在类的方法中通过self调用，不能在类的外面直接调用。</p>
</li>
<li><p>静态方法和类方法：</p>
<ul>
<li><p>静态方法和类方法成员可以通过类名和对象名调用，但不能直接访问属于对象的成员只能访问属于类的成员，不属于任何对象</p>
</li>
<li><p>静态方法使用装饰器@staticmethod声明，类方法使用装饰器@classmethod声明</p>
</li>
</ul>
</li>
<li><p>抽象方法：抽象方法一般定义在抽象类中并要求派生类对抽象方法进行实现</p>
</li>
</ol>
<p><strong>使用类方法：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用类方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>   <span class="hljs-comment">#派生自object类</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function_p</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;在公有方法中调用：&quot;</span>,self.__function())   <span class="hljs-comment">#调用私有方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;公有方法 &#x27;function_p&#x27;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__function</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;私有方法 &#x27;__function&#x27;&quot;</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function_c</span>(<span class="hljs-params">cls</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;类方法 &#x27;function_c&#x27;&quot;</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function_s</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;静态方法 &#x27;function_s&#x27;&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a1 = A()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + a1.function_p())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + a1.function_c())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + a1.function_s())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + A.function_p(a1))      <span class="hljs-comment">#传递对象a1作为参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + A.function_c())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象调用：&quot;</span> + A.function_s())<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.jpg" alt="结果" class="lazyload"></p>
<p><strong>属性：</strong></p>
<ul>
<li><p>一种特殊形式的方法，结合了成员和方法的各自优点，既可以通过属性访问类中的成员，也可以在访问前对用户为成员提供数据的合法性进行检测，还可以设置成员的访问机制</p>
</li>
<li><p>属性通常包括get()方法和se()方法。前者用于获取成员的值，后者用于设置成员的值</p>
</li>
<li><p>也可以包含其他方法如删除方法del()</p>
</li>
</ul>
<p>例：使用属性访问并检查私有成员值的合法性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用属性访问并检查私有成员值的合法性：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span>(<span class="hljs-params">self,radius</span>):</span><br>        <span class="hljs-keyword">if</span> radius&gt;=<span class="hljs-number">0</span>:<br>            self.__radius=radius<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆的面积为：&#123;0&#125;.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.14</span>*self.__radius**<span class="hljs-number">2</span>))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;半径 %f 不在规定范围内（&gt;=0）,请重新设置！&quot;</span>%radius)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__radius<br>        <br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c=Circle()<br>    c.<span class="hljs-built_in">set</span>(<span class="hljs-number">2.5</span>)<br>    c.<span class="hljs-built_in">set</span>(-<span class="hljs-number">2.5</span>)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.jpg" alt="结果" class="lazyload"></p>
<p>使用装饰器@property设置类的属性访问方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用装饰器@property设置类的属性访问方式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,birth</span>):</span><br>        self.__birth=birth<br><span class="hljs-meta">    @property       </span><span class="hljs-comment">#设置属性可读</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">salary</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__salary<br><span class="hljs-meta">    @salary.setter      </span><span class="hljs-comment">#设置属性为可写</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">salary</span>(<span class="hljs-params">self,salary</span>):</span><br>        self.__salary=salary<br><span class="hljs-meta">    @property           </span><span class="hljs-comment">#设置属性为只读8</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">birth</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__birth<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> 	w1=Woman(<span class="hljs-string">&quot;1992.06.06&quot;</span>)<br>    w1.salary=<span class="hljs-number">10800.00</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;您的出生日期%s，薪水：%.2f元&quot;</span>%(w1.birth,w1.salary))<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.jpg" alt="结果" class="lazyload"></p>
<p>使用属性访问私有成员：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用属性访问私有成员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__value<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set</span>(<span class="hljs-params">self,value</span>):</span><br>        self.__value=value<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self.__value<br>    value=<span class="hljs-built_in">property</span>(__get,__<span class="hljs-built_in">set</span>,__<span class="hljs-keyword">del</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> 	t=Test()<br>    t.value=<span class="hljs-number">100</span> <span class="hljs-comment">#写成员</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;value=%d.&quot;</span> %t.value) <span class="hljs-comment">#读成员</span><br>    <span class="hljs-keyword">del</span> t.value<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;value=%d.&quot;</span> %t.value)<br><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/7.jpg" alt="结果" class="lazyload"></p>
<p>特殊方法：</p>
<ul>
<li><p>在python中，类有大量的特殊方法，其中比较常见的是构造方法__init__()和析构方法__del__()</p>
</li>
<li><p>构造方法__init__()用来为类中的成员设置初始值或进行必要的初始化工作，在类实例化时被自动调用和执行</p>
</li>
<li><p>析构方法：__del__()一般用来释放对象占用的资源，在删除对象和回收对象空间时被自动调用和执行</p>
</li>
</ul>
<p>构造方法和析构方法的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,w,h</span>):</span><br>        self.w=w<br>        self.h=h<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;执行构造方法&#x27;</span>)<br>    <span class="hljs-comment">#定义求面积</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.w*self.h<br>    <span class="hljs-comment">#定义析构方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;执行析构方法&#x27;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> 	rect =Rectangle(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)    <span class="hljs-comment">#创建对象，调用构造方法__init__()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;面积为：&quot;</span>,rect.getArea())<br>    <span class="hljs-keyword">del</span> rect        <span class="hljs-comment">#删除对象，调用析构方法__del__()</span><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/8.jpg" alt="结果" class="lazyload"></p>
<h2 id="类的继承："><a href="#类的继承：" class="headerlink" title="类的继承："></a>类的继承：</h2><ul>
<li><p>继承类称为派生类或子类，被继承类成为父类或基类</p>
</li>
<li><p>在python中，派生类可以继承一个父类（单继承）或多个父类（多继承）。</p>
</li>
<li><p>派生类可以继承父类的成员和方法，也可以定义自己的成员方法</p>
</li>
<li><p>如果父类方法不能满足要求，派生类也可以重写父类方法</p>
</li>
<li><p>当派生类继承多个父类时，多个父类之间用逗号隔开</p>
</li>
<li><p>创建派生类的一般格式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">class 派生类（父类1，父类2，。。。）<br>	类体<br></code></pre></td></tr></table></figure></li>
</ul>
<p>类的继承</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类的继承：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,n,a</span>):</span><br>        self.name=n<br>        self.age=a<br><br>    <span class="hljs-comment">#定义公有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&#123;&#125;,今年&#123;&#125;岁&quot;</span>.<span class="hljs-built_in">format</span>(self.name,self.age))<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>(<span class="hljs-params">People</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,n,a,g</span>):</span><br>        People.__init__(self, n, a)<span class="hljs-comment">#调用父类构造方法</span><br>        self.grade=g<br>        <span class="hljs-comment">#重写父类方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&#123;&#125;,今年&#123;&#125;岁,今年&#123;&#125;年级&quot;</span>.<span class="hljs-built_in">format</span>(self.name, self.age,self.grade))<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	s=Student(<span class="hljs-string">&#x27;贾程林&#x27;</span>,<span class="hljs-number">40</span>,<span class="hljs-number">2</span>)<br>    s.speak();<span class="hljs-comment">#调用student类中的speak方法</span><br>    <span class="hljs-built_in">super</span>(Student,s).speak()<span class="hljs-comment">#调用父类people的speak方法</span><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/9.jpg" alt="结果" class="lazyload"></p>
<p>类的多继承：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类的继承：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,n,a</span>):</span><br>        self.name=n<br>        self.age=a<br><br>    <span class="hljs-comment">#定义公有方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&#123;&#125;,今年&#123;&#125;岁&quot;</span>.<span class="hljs-built_in">format</span>(self.name,self.age))<br><span class="hljs-comment">#类的多继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Speaker</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,n,t</span>):</span><br>        self.name=n<br>        self.topic=t<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&#123;&#125;,是一名科学家，今天我演讲的主题是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.name, self.topic))<br><br><span class="hljs-comment">#定义科学家类继承于people和seapker</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scientist</span>(<span class="hljs-params">Speaker,People</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,n,a,t</span>):</span><br>        People.__init__(self,n,a)<br>        Speaker.__init__(self,n,t)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>        Hawkin=Scientist(<span class="hljs-string">&#x27;霍金&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-string">&quot;时间简史&quot;</span>)<br>    	Hawkin.speak()<span class="hljs-comment">#调用继承时排在前面的Speaker类的speak（）方法</span><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10.jpg" alt="结果" class="lazyload"></p>
<p>类的多态：</p>
<ul>
<li><p>多态一般指的是父类的一个方法在不同的派生类对象中具有不同的表现和行为</p>
</li>
<li><p>派生类在继承了父类的行为和属性之后还可能增加某些特性的行为和属性，也可能会对继承父类的行为进行一定的改变，这些都是多态的表现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类的多态：</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am an Animal&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lion</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am a Lion&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tiger</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am a Tiger&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Leopard</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInfo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I am a Leopard&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  objectList=[item()<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> (Animal,Lion,Tiger,Leopard)]<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">in</span> objectList:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">object</span>.getInfo())<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/11.jpg" alt="结果" class="lazyload"></p>
</li>
</ul>
<p>抽象类和抽象方法：</p>
<ul>
<li>抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同但本质上相同的概念抽象</li>
<li>抽象类的特点：抽象类中通常包含抽象方法（没有实现功能），该类不能被实例化，只能被继承，且派生类必须实现抽象类中的抽象方法</li>
<li>Python中一般使用抽象基类（Abstract Base Class，ABC）来实现抽象类</li>
<li>ABC主要定义了基本类和最基本的抽象方法，可以派生类定义公有API，不需要具体实现，相当Java的接口或抽象类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#定义抽象类:</span><br><span class="hljs-keyword">import</span> abc<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People1</span>(<span class="hljs-params">metaclass=abc.ABCMeta</span>):</span><br>    <span class="hljs-comment">#定义抽象方法</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">working</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chinese</span>(<span class="hljs-params">People1</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">working</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;中国人都在勤奋的工作&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  	c1=Chinese()<br>    c1.working()<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/10/08/python%E5%AD%A6%E4%B9%A0%E4%B8%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/12.jpg" alt="结果" class="lazyload"></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="数据结构学习之线性表" class="lazyload">
                    <h1>数据结构学习之线性表</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>8.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 37 分钟</a>
        </div>

        <article>
            
                <h1 id="线性表（linear-list）"><a href="#线性表（linear-list）" class="headerlink" title="线性表（linear list）"></a>线性表（linear list）</h1><p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/0.png"></p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>线性表是具有<strong>相同</strong>数据类型的n(n&gt;=0)个<strong>数据元素</strong>的<strong>有限序列</strong>，其中n为<strong>表长</strong>，当n=0时线性表示一个<strong>空表</strong>。若用L来命名线性表，则其一般表示为：L=（a1,a2,a3，…,an)</p>
<img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/1.jpg">

<p>例如：英文字母表就是一个线性表</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p>a1是线性表中的“第i个”元素线性表的<strong>位序</strong></p>
</li>
<li><p>a1是表头元素；an是表尾元素</p>
</li>
<li><p>除了第一个元素外，每一个元素有且仅有一个<strong>直接前驱</strong>；</p>
<p>除最后一个元素，外每个元素有且仅有一个<strong>直接后继</strong>；</p>
</li>
<li><p>位序从<strong>一</strong>开始，数组下标从<strong>零</strong>开始</p>
</li>
<li><p>同一线性表中的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素间序偶关系</p>
</li>
</ul>
<h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><ol>
<li>从无到有，从有到无：<ul>
<li>InitList(&amp;L):<strong>初始化</strong>表。构造一个空的线性表L，<strong>分配内存空间。</strong></li>
<li>DestroyList(&amp;L):<strong>销毁</strong>操作。销毁线性表，并<strong>释放</strong>线性表L所占用的<strong>内存空间</strong>。</li>
</ul>
</li>
<li>增、删：<ul>
<li>ListInsert(&amp;L)插入操作。在表L中的第i个位置上插入指定的e元素</li>
<li>ListDelete（&amp;L）删除操作，删除表L中的第i个位置的元素，并用e返回删除的元素的值</li>
</ul>
</li>
<li>查：<ul>
<li>LocateElem（L，e）按值查找操作，在表L中查找具有给定关键字值的元素</li>
<li>GetElem（L，i）按位置查找操作，获取表中第i个位置的元素值</li>
</ul>
</li>
<li>其他常用操作：<ul>
<li>Length（L）求表长，返回线性表L的长度，即L中元素个数</li>
<li>PrintList（L）输出表中所有元素</li>
<li>Empty（L）判断表是否为空</li>
</ul>
</li>
</ol>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>对数据的操作（记忆思路）–创销，增删改查</li>
<li>对c语言的定义————&lt;返回值类型&gt; 函数名(&lt;参数1类型&gt;  参数一  &lt;参数二&gt;  参数二  ……)</li>
<li>实际开发中，根据实际需求定义其他基本操作</li>
<li>函数名和参数形式、命名都可改变</li>
<li>什么时候传入引用，及修改原值，传值和传地址参数的区别</li>
</ol>
<h2 id="顺序表（顺序存储）："><a href="#顺序表（顺序存储）：" class="headerlink" title="顺序表（顺序存储）："></a>顺序表（顺序存储）：</h2><p>定义：用<strong>顺序存储</strong>的方式实现线性表。</p>
<p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系</p>
<p>​    ·            由存储单元的邻接关系来体现</p>
<p>sizeof（Elem Type）函数计算数据元素大小</p>
<h3 id="静态分配实现："><a href="#静态分配实现：" class="headerlink" title="静态分配实现："></a>静态分配实现：</h3><p>利用数组这种方式实现静态顺序表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>               <span class="hljs-comment">//分配的存储空间大小为MaxSizen*sizeof（Elemtype）</span><br>    ElemTpye data[Maxsize];  <span class="hljs-comment">//用静态的“数组”存放数据元素，Elemtype可以根据需要更换为实际数据类型</span><br>    <span class="hljs-keyword">int</span> length;             <span class="hljs-comment">//顺序表的当前长度</span><br>&#125; Sqlist;                   <span class="hljs-comment">//顺序表的类型定义（静态模式）（SQ：sequence顺序、序列）</span><br></code></pre></td></tr></table></figure>

<p>int类型的静态顺序表实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Maxsize 10 <span class="hljs-comment">//定义最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data[Maxsize];  <span class="hljs-comment">//用静态的数组存放数据元素</span><br>    <span class="hljs-keyword">int</span> length;         <span class="hljs-comment">//数据表的长度</span><br>&#125; SqList;       <span class="hljs-comment">//顺序表的类型定义</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    <span class="hljs-comment">// for (int i = 0; i &lt; L.length;i++)  //如果不所有的元素赋值为零，则内存中遗留的脏数据则会赋值给data，编译器不同值不同，有的编译器会赋初始值为零</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     L.data[i] = 0;                 //也可省略这一步，因为长度已经规定为零用基本操作访问数据，不会访问到“脏数据”</span><br>    <span class="hljs-comment">// &#125;</span><br>     L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">//顺序表初始长度为零</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SqList L; <span class="hljs-comment">//声明一个顺序表</span><br>    InitList(L); <span class="hljs-comment">//初始化顺序表</span><br>    <span class="hljs-comment">//非法访问查看“脏数据”</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Maxsize;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data[%d]:%d \n&quot;</span>, i, L.data[i]);<br>    &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>查看是否有脏数据：</p>
<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/2.jpg"></p>
<p>可以看到存在脏数据</p>
<p>静态顺序表由于是刚开始就要定义存储空间是静态的，当静态顺序表满了我们直接放弃治疗不扩充</p>
<p>静态顺序表的缺点是浪费存储空间</p>
<h4 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h4><ol>
<li><p>插入数据元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123;   <span class="hljs-comment">//基本操作在L的位序为i的位置插入元素e</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = L.length; j &gt;= i;j--)&#123;    <span class="hljs-comment">//将第i个元素之后的元素向后移动 </span><br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];          <span class="hljs-comment">//注意位序、数组下标的关系，并从后面的元素依次移动</span><br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;  <span class="hljs-comment">//在i处放置元素e</span><br>    L.length++;  <span class="hljs-comment">//长度增加</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于这样的做法无法给用其他人调用的体验有反馈值，加上当数据元素满了时没有错误反馈所以改进为以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> e)</span></span>&#123;   <span class="hljs-comment">//基本操作在L的位序为i的位置插入元素e</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)   <span class="hljs-comment">//判断i的范围是否有效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(L.length&gt;=Maxsize)   <span class="hljs-comment">//当存储空间满了不能插入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = L.length; j &gt;= i;j--)&#123;    <span class="hljs-comment">//将第i个元素之后的元素向后移动 </span><br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];          <span class="hljs-comment">//注意位序、数组下标的关系，并从后面的元素依次移动</span><br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;  <span class="hljs-comment">//在i处放置元素e</span><br>    L.length++;  <span class="hljs-comment">//长度增加</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入操作的时间复杂度计算：</p>
<p>最好情况：新插入的元素插入到表尾，不需要移动元素吗，i=n+1,循环0次，最好时间复杂度为O(1)</p>
<p>最坏情况：新插入元素在表头，将原有的n个元素全向后移动，i=1，循环n次最坏时间复杂度O(n)</p>
<p>平均情况：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">新元素插入有(n+1)种选择,即插入每个位置的概率都是 p= 1/(n+1)<br>i =1 ,循环n次<br>i =2 ,循环n-1次<br>…<br>i =n+1, 循环 0次<br><br>平均循环次数: = np+(n-1)p+…+1*p = n/2<br>即 平均时间复杂度 = O(n)<br></code></pre></td></tr></table></figure></li>
<li><p>顺序表的删除：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> &amp;e)</span></span>&#123;  <span class="hljs-comment">//此处e不加引用法将第i个元素的值传出去</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length)     <span class="hljs-comment">//判断i的范围是否合法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    e = L.data[i - <span class="hljs-number">1</span>];      <span class="hljs-comment">//将第ige位置的元素值赋给e</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; L.length;j++)&#123;  <span class="hljs-comment">//将第i个位置后的元素向前移</span><br>      gailuxiangt  L.data[j - <span class="hljs-number">1</span>] = L.data[j]; <span class="hljs-comment">//注意位序、数组下标的关系并从前面的元素以次移动</span><br>    &#125;							<span class="hljs-comment">//要与插入是分辨开</span><br>    L.length--;   <span class="hljs-comment">//线性表长度减一</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>删除操作的时间复杂度：</p>
<p>最好情况：删除表尾元素不需要移动其他元素 i=n,循环0次；最好时间复杂度O(1)</p>
<p>最坏情况：删除表头元素,需要将后续的n-1个元素全部向前移动,i=1，循环n-1次最坏时间复杂度O(n)</p>
<p>平均情况：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">删除操作有n种选择,即删除每个位置的概率都是 p= 1/n<br>i =1 ,循环n-1次<br>i =2 ,循环n-2次<br>…<br>i =n, 循环 0次<br><br>平均循环次数: = (n-1)p+…+1*p = (n-1)/2<br>即 平均时间复杂度 = O(n)<br></code></pre></td></tr></table></figure>

<p><strong>插入和删除结果：</strong></p>
<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/4.jpg"></p>
</li>
<li><p>顺序表的查找：</p>
<ul>
<li><p>顺序表的按位查找：时间复杂度：O(1),由于存放是连续的所以可以实现随机存取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">Elemtype <span class="hljs-title">Getelemtype</span><span class="hljs-params">(SqList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.data[i - <span class="hljs-number">1</span>];<span class="hljs-comment">//数组元素下标从零开始所以i-1</span><br>&#125;<br><span class="hljs-comment">//加入判断i的值是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Getelem</span><span class="hljs-params">(SqList L,<span class="hljs-keyword">int</span> i,Elemtype e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||i&gt;L.length)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        e = L.data[i];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>顺序表的按值查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.data[i]==e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//以int类型为例则为</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,<span class="hljs-keyword">int</span> e)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.data[i]==e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在进行元素对比时<strong>两个结构体不能直接用“==”比较</strong>，必须分别比较结构体内的每一个分量是否相等，也可以实现一个相等判断的方法来调用。</p>
<p>时间复杂度：（问题规模n=L.length)</p>
<ol>
<li>最好情况：目标元素在表头，循环一次，最好时间复杂度=O(1)</li>
<li>最坏情况：目标元素在表尾，循环n次，最好时间复杂度=O(n)</li>
<li>平均情况：</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">假设目标元素出现在每个位置的概率都是 p= 1/n<br>目标元素在第1位 ,循环1次<br>目标元素在第2位,循环2次<br>…<br>目标元素在第n位, 循环n次<br><br>平均循环次数: = 1*(1/n)+2*(1/n)+...+n*(1/n)=(n+1)/2<br>即 平均时间复杂度 = O(n)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>两种查找的测试结果：</strong></p>
<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/5.jpg"></p>
<p>还有一些简单的基本操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//清空顺序表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>    L.length = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//获得顺序表的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><span class="hljs-comment">//输出表中所有元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;L.length;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;L.data[%d]:%d \n&quot;</span>, i, L.data[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//判断表是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==*L.data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="动态分配实现"><a href="#动态分配实现" class="headerlink" title="动态分配实现"></a>动态分配实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//动态分配顺序表</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Initsize 10  <span class="hljs-comment">//顺序表的初始长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>         <br>    Elemtype *data;    <span class="hljs-comment">//动态分配数组指针</span><br>    <span class="hljs-keyword">int</span> MaxSize;        <span class="hljs-comment">//顺序表的最大容量</span><br>    <span class="hljs-keyword">int</span> lenght;         <span class="hljs-comment">//当前顺序表的长度</span><br>&#125;SeqList;               <span class="hljs-comment">//顺序表的定义类型（动态分配）</span><br></code></pre></td></tr></table></figure>

<p>关键点：动态分配和释放空间 </p>
<p>c语言中利用malloc、free函数来动态申请和释放空间，使用malloc、free函数需要使用这个库文件#include&lt;stdlib.h&gt;</p>
<p>c++则使用new、delete来动态申请和释放空间</p>
<p>int类型动态顺序表的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Initsize 10  <span class="hljs-comment">//顺序表的初始长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>         <br>    <span class="hljs-keyword">int</span> *data;    <span class="hljs-comment">//动态分配数组指针</span><br>    <span class="hljs-keyword">int</span> MaxSize;        <span class="hljs-comment">//顺序表的最大容量</span><br>    <span class="hljs-keyword">int</span> lenght;         <span class="hljs-comment">//当前顺序表的长度</span><br>&#125;SeqList;               <span class="hljs-comment">//顺序表的定义类型（动态分配）</span><br><br><span class="hljs-comment">//动态初始化</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SeqList &amp;L)</span></span>&#123;<br>    <span class="hljs-comment">//用malloc函数来申请一片连续的存储空间</span><br>    L.data = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * Initsize);<br>    L.lenght = <span class="hljs-number">0</span>;<br>    L.MaxSize = Initsize;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(SeqList &amp;L,<span class="hljs-keyword">int</span> len)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> * p = L.data;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;, p[0]);</span><br>    L.data=(<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*(L.MaxSize+len));<span class="hljs-comment">//新申请的空间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;L.lenght;i++)&#123;<br>        L.data[i] = p[i];                      <span class="hljs-comment">//将原来的数据保存到新空间</span><br>    &#125;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;, L.data[0]);</span><br>    L.MaxSize=L.MaxSize+len;<br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//释放原来的内存空间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    SeqList L;<span class="hljs-comment">//声明一个顺序表</span><br>    InitList(L);<span class="hljs-comment">//初始化顺序表</span><br>    <span class="hljs-comment">//向顺序表中插入数据。。。</span><br>    L.lenght = <span class="hljs-number">10</span>;<br>    L.data[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    L.data[<span class="hljs-number">8</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// printf(&quot;%d\n&quot;,L.data[0]);</span><br>    IncreaseSize(L, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;增加后原来数据还在否，L.data[0]=%d,L.data[8]=%d\n&quot;</span>, L.data[<span class="hljs-number">0</span>],L.data[<span class="hljs-number">8</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;增加后的空间长度:%d&quot;</span>,L.MaxSize);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/3.jpg"></p>
<h4 id="基本操作：-1"><a href="#基本操作：-1" class="headerlink" title="基本操作："></a>基本操作：</h4><p>插入操作、删除操作、查找操作：</p>
<p>由于动态分配创建的顺序表可以用类似访问数组的方式访问所以其插入操作、删除操作、查找操作与静态方法相同其访问过程是通过定义的指针指向申请空间的首地址，然后通过计算类型空间大小，指出数组下标对应的空间地址，在使用malloc函数申请空间时已经 强制定义了类型，不同类型用的空间大小不同。</p>
<h4 id="顺序表的特点："><a href="#顺序表的特点：" class="headerlink" title="顺序表的特点："></a>顺序表的特点：</h4><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>随机访问，即可以在O（1）时间内找到第i个元素的值（数组下标访问）</li>
<li>存储密度高，每个节点只存储数据元素</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><ol>
<li>拓展容量不方便（即使使用动态分配的方式实现，拓展的时间复杂度比较高）</li>
<li>插入删除操作不方便，需要移动大量元素</li>
</ol>
<h2 id="链表（链式存储）："><a href="#链表（链式存储）：" class="headerlink" title="链表（链式存储）："></a>链表（链式存储）：</h2><p>​        链表是物理存储单元上非连续、非顺序的存储结构。与我们之前学习过的数组同为存储结构，区别是数组是连续的、顺序的存储结构。</p>
<h3 id="链式存储结构的特点是："><a href="#链式存储结构的特点是：" class="headerlink" title="链式存储结构的特点是："></a>链式存储结构的特点是：</h3><p>​        用一组任意的存储单元存储线性表的数据元素（可连续可不连续）。</p>
<h3 id="结点："><a href="#结点：" class="headerlink" title="结点："></a>结点：</h3><p>​        数据元素的存储映像：数据元素的本身信息和后继元素的逻辑关系。</p>
<h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><p>是链表中最简单的单向链表，每一个结点除了存放数据元素外，还要存储指向下一个结点的指针</p>
<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/6.jpg"></p>
<p>信息域：存储数据元素信息</p>
<p>指针域：存储直接后继存储位置的域，其中存储的信息位指针或链</p>
<p>从上图可知：</p>
<ul>
<li>单链表的每一个节点里面有一个信息域（element）和一个指向下一个节点的指针（next）。</li>
<li>查找一个节点是从第一个节点（head）找起。</li>
</ul>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>不要求大片连续空间</li>
<li>改变容量方便</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>不可随机存取</li>
<li>要耗费一定空间存放指针</li>
</ol>
<h4 id="代码定义："><a href="#代码定义：" class="headerlink" title="代码定义："></a>代码定义：</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Elemtype;<br><span class="hljs-comment">//定义结点：</span><br><span class="hljs-comment">// struct Lnode&#123;</span><br><span class="hljs-comment">//     Elemtype data;</span><br><span class="hljs-comment">//     struct Lnode *next;</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// typedef struct Lnode LNode;</span><br><span class="hljs-comment">// typedef struct Lnode * LinkList;</span><br><span class="hljs-comment">//以下的定义等价与上面注释的定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span>&#123;</span>  <span class="hljs-comment">//定义单链表结点类型</span><br>    Elemtype data;     <span class="hljs-comment">//定义结点存放一个数据元素</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span>       <span class="hljs-comment">//定义一个指向下一个结点的置置</span><br>&#125;LNode, *LinkList;          <br><span class="hljs-comment">/*LinkList为指向结构体LNode的指针，Linklist与LNode*两者等价</span><br><span class="hljs-comment">利用struct Lnode *p=(struct LNode *)malloc(sizeof(Struct LNode))</span><br><span class="hljs-comment">申请空间,增加一个新结点并用p指针指向这个结点 </span><br><span class="hljs-comment">在书写时并不方便，所以使用typedef关键字为数据类型重命名</span><br><span class="hljs-comment">其格式：typedef &lt;数据类型&gt;&lt;别名&gt;</span><br><span class="hljs-comment">LNode*这中强调的时返回一个结点</span><br><span class="hljs-comment">LinkList这是强调定义的是一个单链表</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p><strong>LNode*这中强调的时返回一个结点</strong><br><strong>LinkList这是强调定义的是一个单链表</strong></p>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个空的单链表(不带头结点)</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//空表，暂时还没有任何结点  防止脏数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//初始化一个带头结点的单链表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitListD</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//判断单链表是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <span class="hljs-comment">// if(L == NULL)</span><br>    <span class="hljs-comment">//     return true;</span><br>    <span class="hljs-comment">// else</span><br>    <span class="hljs-comment">//     return false;</span><br>    <span class="hljs-keyword">return</span> (L == <span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-comment">//判断带头结点的单链表是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmptyD</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;   <br></code></pre></td></tr></table></figure>

<p> 首元结点：是指链表中存储第一个数据元素的结点</p>
<p>头结点：是在首结点之前附设的一个结点，其指针域指向首结点，其数据域可不存储任何信息，也               可存储与数据元素类型相同的其他附加信息,在理解时可以将头结点看作时第0个结点。</p>
<p>头指针：是指向链表中第一个节点的指针，有头结点，则头指针所指结点为线性表的头结点，若无              头结点则头指针所指结点为线性表的首元结点</p>
<p>带头结点写代码方便，不带头结点对于第一个数据节点的后续节点的处理需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑</p>
<p>单链表的插入和删除：</p>
<h4 id="插入操作："><a href="#插入操作：" class="headerlink" title="插入操作："></a>插入操作：</h4><ol>
<li><p>按位序插入:(在表L中的第i个位置插入指点元素e，首先找到第i-1个结点，将新结点插入其后)</p>
<ul>
<li><p>带头结点:(在i=1的位置插入，可以把头结点看成是<strong>第0个结点</strong>用基本逻辑就可实现)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//带头结点插入</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Listsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,Elemtype e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *p;      <span class="hljs-comment">//指针p指向当前扫描到的结点</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">//当前p指向第几个结点</span><br>    p=L;           <span class="hljs-comment">//L指向头结点，头结点是第0个结点（不存放数据）</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)   <span class="hljs-comment">//循环找到第i-1个结点推出循环</span><br>    &#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">//return InsertNextNode(p, e); //用后插代替下面的代码调用函数</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//i值不合法超过当前链长</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<span class="hljs-comment">//顺序不能反，否则会使链断</span><br>    p-&gt;next = s;<span class="hljs-comment">//将结点s连到p之后</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//插入成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析：</p>
<p>当i=1（插在表头），首先查找到头结点然后申请一个新的结点，新结点的数据域赋值为e，然后将新结点的next指针指向头结点中的next所指的位置；然后头结点的next指针指向新申请的结点，这样就可以将链连起来。若顺序颠倒在断链后续结点无法找到。因为只在头结点后插入，所以循环跳过时间复杂度为O(1).</p>
<p>当i=3（插在表中）,首先在循环中查找到第i-1个结点，在第i-1个结点插入新结点</p>
<p>当i等于表尾，在循环中当p指向要插入位置的前一个结点时由于j++后不满足即推出循环找到插入位置的前一个结点，p不为空然后将新结点连入链表中，时间复杂度为O(n)n为表长</p>
<p>当i大于链表的最大长度+1则会由于p!=NULL这个条件跳出循环和p=NULL返回false</p>
</li>
<li><p>不带头结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//不带头结点的插入：</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListSertD</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,Elemtype e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;       <span class="hljs-comment">//由于不带头结点其逻辑和一般插入逻辑不同所以单独操作</span><br>        Lnode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>        s-&gt;data = e;<br>        s-&gt;next = L;<br>        L=s;    <span class="hljs-comment">//头指针指向新结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    Lnode *p = L;<span class="hljs-comment">//指针p指向当前扫描的结点，指向第1个结点，不是头结点无头结点</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;  <span class="hljs-comment">//当前p指向第几个结点</span><br>     <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)   <span class="hljs-comment">//循环找到第i-1个结点</span><br>    &#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">//return InsertNextNode(p, e);//调用后插函数代替下面的代码</span><br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//i值不合法超过当前链长</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<span class="hljs-comment">//顺序不能反，否则会使链断</span><br>    p-&gt;next = s;<span class="hljs-comment">//将结点s连到p之后</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//插入成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析：</p>
<p>当i=1(无头结点插在表头)，不带头结点则插入删除第1个元素时只需要更改头指针L，后续更改插入与带头结点的逻辑相同</p>
<p>结论：</p>
<p>推荐使用带头结点的写代码方便，不带头结点不方便（考试两种都要考察）</p>
</li>
</ul>
</li>
<li><p>指定结点的后插：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//指定结点的后插操作：</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertNextNode</span><span class="hljs-params">(Lnode *p,Elemtype e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>)         <span class="hljs-comment">//内存分配失败（某些情况可能发生）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;data = e;        <span class="hljs-comment">//用结点s保存数据元素e</span><br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;        <span class="hljs-comment">//将结点s连到p之后</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以前面找到第i-1个结点后就可以调用后插函数了</p>
</li>
<li><p>指定节点的前插：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//指定结点的前插操作：</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertPriorNode</span><span class="hljs-params">(LinkList L, Lnode *p, Elemtype e)</span> </span>&#123;<br>    Lnode *q=L;<span class="hljs-comment">//q指针查找p的前驱结点</span><br>    <span class="hljs-keyword">while</span>(q-&gt;next!=p)&#123;<br>        q = q-&gt;next;   <br>    &#125;<br>    InsertNextNode(q, e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-comment">//传入头指针即可利用循环查找到所有结点信息找到指定结点的前一个结点新结点插到其后连起来</span><br> <span class="hljs-comment">//其时间复杂度为O(n)</span><br> <br> <span class="hljs-comment">//偷天换日法实现前插其时间复杂度为O（n）：</span><br> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertPriorNodeT</span><span class="hljs-params">(Lnode *p,Elemtype e)</span></span>&#123;<br>     <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     Lnode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>     s-&gt;next = p-&gt;next;<br>     p-&gt;next = s;<br>     s-&gt;data = p-&gt;data;<br>     p-&gt;data = e;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="删除操作-针对与带头结点的删除-删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值"><a href="#删除操作-针对与带头结点的删除-删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值" class="headerlink" title="删除操作(针对与带头结点的删除):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值"></a>删除操作(针对与带头结点的删除):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</h4><p>找到第i-1个结点，将其指针指向第i+1个结点</p>
<ol>
<li><p>按位序删除：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位序删除结点（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-keyword">int</span> i,Elemtype &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *p;<span class="hljs-comment">//指针p指向当前扫描到的结点</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前p指向第几个结点</span><br>    p = L;<span class="hljs-comment">//指向头结点</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;j&lt;i<span class="hljs-number">-1</span>)<br>    &#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//当前传入的i值不合法</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//第i-1个节点之后以无其他结点</span><br>    Lnode *q = p-&gt;next;<br>    e = q-&gt;data;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-comment">//最好时间复杂度O(1)  最坏、平均时间复杂度：O（n）</span><br></code></pre></td></tr></table></figure></li>
<li><p>指定结点删除：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除指定结点(两种：1、传入头指针查找删除   2、偷天换日法)</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteNode</span><span class="hljs-params">(Lnode *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode *q = p-&gt;next;<span class="hljs-comment">//q指向*p的后继结点</span><br>    p-&gt;data = p-&gt;next-&gt;data;<span class="hljs-comment">//和后继结点交换数据</span><br>    p-&gt;next = q-&gt;next;      <span class="hljs-comment">//将*q结点从链中断开</span><br>    <span class="hljs-built_in">free</span>(q);                <span class="hljs-comment">//释放后继结点的存储空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-comment">//时间复杂度为O(1);</span><br><br><span class="hljs-comment">//传入头指针</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteNodeT</span><span class="hljs-params">(LinkList &amp;L,Lnode *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>||p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Lnode * q = L;<br>    <span class="hljs-keyword">while</span>(q-&gt;next!=p)<br>        q = q-&gt;next;<br>    <span class="hljs-keyword">if</span>(q-&gt;next-&gt;next==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(p);<br>        q-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    q-&gt;next = p-&gt;next;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码存在一个问题：当p是最后一个节点q则为空指针，就只能用从表头开始一次寻找p的前驱的方法删除时间复杂度为O(n),这也是单链表的局限性，无法逆向检索，有时不太方便。</p>
</li>
</ol>
<h4 id="查找操作（带头结点）："><a href="#查找操作（带头结点）：" class="headerlink" title="查找操作（带头结点）："></a>查找操作（带头结点）：</h4><ol>
<li><p>按位查找操作：获取表L中第i个位置的元素的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找（带头结点）</span><br><span class="hljs-function">Lnode * <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Lnode *p;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    p = L;<br>    <span class="hljs-keyword">while</span> ( p!=<span class="hljs-literal">NULL</span> &amp;&amp; j &lt; i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">/*当i=0时直接返回头结点</span><br><span class="hljs-comment">当i大于链表的实际长度返回一个空指针NULL</span><br><span class="hljs-comment">平均时间复杂度为O（n）</span><br><span class="hljs-comment">上节课的找到第i-1个结点更加方便</span><br><span class="hljs-comment">将常用代码封装成函数可以避免重复代码，简介易维护</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p>按值查找操作：在表中查找具有给定关键字值的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找(带头结点）：</span><br><span class="hljs-function">Lnode * <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L,Elemtype e)</span></span>&#123;<br>    Lnode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">平均时间复杂度O（n）</span><br><span class="hljs-comment">判断的时候Elemtype是结构体，结构体判断不能直接用等于号，写函数判断</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
<li><p>求表长:函数代码与查找类似故加在此处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求表长</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    Lnode *p=L;<br>    <span class="hljs-keyword">while</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        p = p-&gt;next;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>​        由于单链表不具备随机访问的特性，只能一次扫描，所以三种基本操作的时间复杂度为O(n),在编写代码时要注意边界值的处理。</p>
<h4 id="单链表的建立方法："><a href="#单链表的建立方法：" class="headerlink" title="单链表的建立方法："></a>单链表的建立方法：</h4><ol>
<li><p>尾插法：（含有一个尾指针）</p>
<p>第一步初始化一个单链表、第二步每一次取一个数据元素，插入到表尾、表头</p>
<p>尾插法建立单链表：初始化单链表，设置变量记录链表长度，利用while循环每次取一个数据元素插入到length+1个位置然后length++；这种插入方式每次都从开头开始遍历，其时间复杂度就为O（n的平方）</p>
<p>我们可以设置一个尾指针来减小时间复杂度，每一次将新的数据元素插在尾指针后边</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//尾插法建立单链表</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_Tailnsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//正向建立单链表</span><br>    <span class="hljs-keyword">int</span> x;<span class="hljs-comment">//设置elemtype为整形</span><br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<span class="hljs-comment">//建立头结点  -----&gt;初始化一个空表</span><br>    Lnode *s, *r = L;<span class="hljs-comment">//r为尾指针</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)  <span class="hljs-comment">//9999只是一个结束的标志</span><br>    &#123;      <span class="hljs-comment">//在r结点之后插入元素x</span><br>        s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<br>        s-&gt;data = x;<br>        r-&gt;next = s;        <br>        r = s;          <span class="hljs-comment">//r指向新表结尾  ---------&gt;保证r永远指向最后一个结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">//尾指针制空</span><br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><span class="hljs-comment">//时间复杂度为O(n)</span><br></code></pre></td></tr></table></figure></li>
<li><p>头插法：</p>
<p>第一步初始化一个单链表，第二部在while循环中获取一个数据元素，插入到头结点之后</p>
<p>时间复杂度仍然为O（n）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//头插法建立单链表</span><br><span class="hljs-function">LinkList <span class="hljs-title">List_Headinsert</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">//逆向建立单链表（输入的是逆向排序</span><br>    Lnode *s;<br>    <span class="hljs-keyword">int</span> x;<br>    L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<span class="hljs-comment">//创建头结点</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;                 <span class="hljs-comment">//初始为空链表</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);                <span class="hljs-comment">//输入结点的值</span><br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;     <span class="hljs-comment">//结束标志</span><br>        s = (Lnode *)<span class="hljs-built_in">malloc</span>(sizzeof(Lnode));<span class="hljs-comment">//创建新结点</span><br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;        <span class="hljs-comment">//将新节点插入表中，L为头指针</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><span class="hljs-comment">//养成良好的编程习惯只要初始化单链表，都先把头指针指向NULL，若不指向空指针则会指向内存中遗留的脏数据影响代码的运行</span><br><br></code></pre></td></tr></table></figure>

<p>头插法可以运用与链表的逆置</p>
</li>
</ol>
<h3 id="双链表："><a href="#双链表：" class="headerlink" title="双链表："></a>双链表：</h3><p>​    单链表无法逆向检索,有时候不太方便,于是乎产生了双链表,它可进可退,但存储密度更低一些</p>
<p>​    只需要在单链表的基础上在增加一个指针域来指向前驱结点,prior(先前的),双链表中的一个结点叫    Dnode.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dnode</span>&#123;</span>  <span class="hljs-comment">//定义双链表结点类型</span><br>    Elemtype data;  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dnode</span> *<span class="hljs-title">prior</span>, *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//前驱指针和后继指针</span><br>&#125; Dnode, *DLinklist;<br></code></pre></td></tr></table></figure>

<p>初始化双链表(带头结点):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化双链表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitDLinkList</span><span class="hljs-params">(DLinklist &amp;L)</span></span>&#123;<br>    L = (Dnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Dnode)); <span class="hljs-comment">//分配一个头结点</span><br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>)     <span class="hljs-comment">//内存不足分配失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头结点的prior永远指向NULL</span><br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头结点之后暂时还没有结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是否为空(带头结点):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//是否为空（带头结点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(DLinklist L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双链表的插入:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//双链表的插入(后插实现)</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertNextDnode</span><span class="hljs-params">(Dnode *p,Dnode *s)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> || s == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;next = p-&gt;next;<span class="hljs-comment">//将结点*s插入到结点*p之后</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)   <span class="hljs-comment">//如果p结点有后继结点执行</span><br>        p-&gt;next-&gt;prior = s;<br>    s-&gt;prior = p;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//需要注意修改指针的顺序，顺序不当会使后续结点信息丢失</span><br></code></pre></td></tr></table></figure>

<img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" style="zoom:100%;">

<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png"></p>
<p>在进行前插操作时我们可以找到给定结点的前前驱结点然后在后插实现</p>
<p>双链表的删除操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//双链表的删除操作（删除给定结点的后继节点）</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteNextDnode</span><span class="hljs-params">(Dnode *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Dnode *q = p-&gt;next; <span class="hljs-comment">//找到p的后继结点</span><br>    <span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)     <span class="hljs-comment">//p没有后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-keyword">if</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)   <span class="hljs-comment">//q结点不是最后一个结点</span><br>        q-&gt;next-&gt;prior = p;<br>    <span class="hljs-built_in">free</span>(q);        <span class="hljs-comment">//释放结点空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/7.jpg"></p>
<p>销毁一个双链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//销毁一个双链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestoryDList</span><span class="hljs-params">(DLinklist &amp;L)</span></span>&#123;<br>    <span class="hljs-comment">//循环释放各个数据结点</span><br>    <span class="hljs-keyword">while</span>(L-&gt;next!=<span class="hljs-literal">NULL</span>)	<span class="hljs-comment">//直到头结点后再无其他结点</span><br>        DeleteNextDnode(L);<br>    <span class="hljs-built_in">free</span>(L);    <span class="hljs-comment">//释放头结点</span><br>    L = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//释放头指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>双链表的遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//双链表的遍历(ergodic)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ergodic</span><span class="hljs-params">(DLinklist L)</span></span>&#123;<br>    Dnode *p = L-&gt;next;<br>    <span class="hljs-comment">//后向遍历</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        p = p-&gt;next;<br>        <span class="hljs-comment">//做相应的处理</span><br>    &#125;<br>    <span class="hljs-comment">//循环完成p已经指向尾部</span><br>    <span class="hljs-comment">//向前遍历</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-comment">//对结点p做相应的处理</span><br>        p = p-&gt;prior;<br>    &#125;<br>    <span class="hljs-comment">//向前遍历跳过头结点</span><br>    <span class="hljs-keyword">while</span>(p-&gt;prior!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-comment">//对p结点做相应的处理</span><br>        p = p-&gt;prior;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//求长度设置变量统计，按值查找的话只需要在处理时进行值对比其时间复杂度O(n)</span><br></code></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>只需要在单链表和双链表的基础上做一些小改动即可</p>
<h4 id="循环单链表："><a href="#循环单链表：" class="headerlink" title="循环单链表："></a>循环单链表：</h4><p>​        只需将单链表尾结点的next指针指回头结点即可，在初始化时也要将头结点的next指针指向自己，判断循环单链表是否为空只需要判断（L-&gt;next==L)即可,若成立则为空的循环单链表，在判断一个结点是否为循环单链表的尾结点时只需要判断这个结点的next指针指向是否为头结点。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>​        从一个结点出发可以找到其他任何一个结点，由于尾结点的next指针指向头结点，而单链表就没有这种特性。</p>
<p>​        普通的循环单链表从头结点找到尾部结点的时间复杂度为为O(n)要遍历整个链表，但是如果我们将循环单链表的指针一开始就指向尾部结点查找时其时间复杂度就为O(1)，由于可循环这样也是可以访问整个循环单链表的。当循环单链表指针指向尾结点时在对表尾进行插入删除操作时需要修改循环单链表的指针指向。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个循环单链表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitListX</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<span class="hljs-comment">//分配一个头结点</span><br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>)     <span class="hljs-comment">//内存不足分配失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;next = L;        <span class="hljs-comment">//头结点next指向头结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//判断循环单链表是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Emptyx</span><span class="hljs-params">(LinkList L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next==L)  <span class="hljs-comment">//循环单链表尾结点的next指针指向头结点，与初始化中对应</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//判断结点p是否为循环单链表的表尾结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTail</span><span class="hljs-params">(LinkList L,Lnode *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==L)  <span class="hljs-comment">//循环单链表和单链表的主要区别就在尾结点的处理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//对尾结点的处理一定要掌握。</span><br></code></pre></td></tr></table></figure>



<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>​        只需要将普通双链表头结点的prior指针指向表尾结点，表尾结点的next指针指向头结点即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化空的循环双链表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InitDLinkListx</span><span class="hljs-params">(DLinklist &amp;L)</span></span>&#123;<br>    L = (Dnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Dnode)); <span class="hljs-comment">//分配一个头结点</span><br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>)     <span class="hljs-comment">//分配失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = L;       <span class="hljs-comment">//头结点的Prior指向头结点</span><br>    L-&gt;next = L;        <span class="hljs-comment">//头结点的next指向头结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//判断循环双链表是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Emptyx</span><span class="hljs-params">(DLinklist L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next==L)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//判断结点p是否为循环双链表的表尾结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isTailx</span><span class="hljs-params">(DLinklist L,Dnode *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;next==L)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="循环双链表的基本操作："><a href="#循环双链表的基本操作：" class="headerlink" title="循环双链表的基本操作："></a>循环双链表的基本操作：</h5><ol>
<li><p>插入操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//插入操作：在p结点之后插入s结点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">InsertNextDnodex</span><span class="hljs-params">(Dnode *p,Dnode *s)</span></span>&#123;<br>    s-&gt;next = p-&gt;next;      <span class="hljs-comment">//将结点*s插入到结点*p之后</span><br>    p-&gt;next-&gt;prior = s;<br>    s-&gt;prior = p;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>删除操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//双链表的删除</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">DeleteDnodex</span><span class="hljs-params">(Dnode *p,Dnode *q)</span></span>&#123;      <span class="hljs-comment">//删除p的后继结点q</span><br>    p-&gt;next = q-&gt;next;<br>    q-&gt;next-&gt;prior = p;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="在操作循环单（双）链表时注意的地方："><a href="#在操作循环单（双）链表时注意的地方：" class="headerlink" title="在操作循环单（双）链表时注意的地方："></a>在操作循环单（双）链表时注意的地方：</h4><ol>
<li>如何判断表空</li>
<li>如何判断结点p是否尾头结点</li>
<li>如何在表头、表尾、表中插入或删除一个结点</li>
</ol>
<h3 id="静态链表："><a href="#静态链表：" class="headerlink" title="静态链表："></a>静态链表：</h3><p>​    分配一整个连续的内存空间，各个结点集中安置。每一个结点中有一个数据域和一个下标域。用数组方式实现的链表，先申请一片连续的空间，空间内部每一个结点的逻辑关系并不是和数组的位序关系确定而是由每一个结点中的游标来确定相互间的关系。位序为0的数组结点为头结点，而游标对应的就是数组下标。（数组内部混乱）</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8/8.jpg" alt="静态链表" class="lazyload"></p>
<p><strong>特点</strong>：</p>
<p>优点：增删操作不许要移动大量元素</p>
<p>缺点：不能随机存取，只能从头结点开始一次往后找，<strong>容量固定不变</strong>。</p>
<h2 id="顺序表和链表的比较："><a href="#顺序表和链表的比较：" class="headerlink" title="顺序表和链表的比较："></a>顺序表和链表的比较：</h2><ol>
<li><p>逻辑结构：</p>
<ul>
<li>顺序表和链表都时线性结构</li>
</ul>
</li>
<li><p>物理结构/存储结构：</p>
<ul>
<li><p>顺序表采用顺序存储，链表采取链式存储</p>
</li>
<li><p>顺序表支持随机存取，存取密度高，但大片连续空间分配不方便，改变容量不方便</p>
<p>链表离散小空间分配，改变容量方便，但不支持随机读取，只能从表头开始查找，由于每个结点要存储指针所以存取密度低</p>
</li>
</ul>
</li>
<li><p>数据的运算/基本操作：</p>
<p>创销增删改查在上文已经详细记录</p>
</li>
</ol>
<p>如何选择这两种方式：</p>
<ol>
<li>当需要的线性表表长难以估计、经常需要增减删除元素时选择链表</li>
<li>表长可预估、查询搜索操作较多时选择顺序表</li>
</ol>
<h1 id="本文结束"><a href="#本文结束" class="headerlink" title="本文结束"></a>本文结束</h1>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="数据结构学习" class="lazyload">
                    <h1>数据结构学习</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.8k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 7 分钟</a>
        </div>

        <article>
            
                <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构在学什么？"><a href="#数据结构在学什么？" class="headerlink" title="数据结构在学什么？"></a>数据结构在学什么？</h2><p>​        用程序代码把现实世界的问题信息化，并利用计算机高效的处理这些信息并且创造价值。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>​        数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合，数据是计算机程序加工的原料。对于计算机来说就是0 1。</p>
<p>​        数据元素:是数据的基本单位，通常作为一个整体进行考虑和处理。由数据项组成，数据项是构成数据元素不可分割的最小单位。</p>
<p><img src="/2021/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/1.jpg"></p>
<h2 id="数据结构、数据对象："><a href="#数据结构、数据对象：" class="headerlink" title="数据结构、数据对象："></a>数据结构、数据对象：</h2><p>​    数据结构：是相互之间存在的一种或多种<strong>特定关系</strong>的数据元素的集合。</p>
<p>​    数据对象：是具有<strong>相同性质</strong>的数据元素的集合，是数据的一个子集。</p>
<h2 id="数据结构的三要素（要关注的三个方面）："><a href="#数据结构的三要素（要关注的三个方面）：" class="headerlink" title="数据结构的三要素（要关注的三个方面）："></a>数据结构的三要素（要关注的三个方面）：</h2><ol>
<li><p>逻辑结构：数据元素之间的逻辑关系</p>
<p>数据的逻辑结构：</p>
<ul>
<li><p>集合：各个元素同属一个集合，别无其他关系。</p>
</li>
<li><p>线性结构：数据元素之间是一对一的关系；除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。</p>
</li>
<li><p>树形结构：数据元素之间是一对多的关系。</p>
</li>
<li><p>图状结构（网状结构）：数据元素之间是多对多的关系。</p>
<p><img src="/2021/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/2.jpg"></p>
</li>
</ul>
</li>
<li><p>物理结构（存储结构）：用计算机表示数据元素的逻辑关系</p>
<p>数据的存储结构：（存储结构会影响存储空间的分配方便程度）</p>
<p>顺序存储（物理上必须是连续的）：</p>
<ul>
<li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，它们之间的关系由存储单元的邻接关系体现。（分配一段连续的存储空间）</li>
</ul>
<p>非顺序存储（物理上可以是离散的，对空间的分配更方便）：</p>
<ul>
<li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助<strong>指针</strong>来表示元素间的逻辑关系。</li>
<li>索引存储：在存储元素信息的同时建立索引表，索引表中的每项称索引项其一般形式是（关键字，地址）</li>
<li>散列存储：根据元素的关键字直接计算出该元素的存储地址，称哈希存储（hash）</li>
</ul>
<p>不同的存储结构影响都数据的运算速度。</p>
</li>
<li><p>数据运算：</p>
<p>​        施加在数据上的运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能，运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
</li>
</ol>
<h2 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h2><p>数据类型（一个值的集合和定义在此集合上的一组操作的总称）：</p>
<ol>
<li>原子类型（值不可再分割）：bool、int</li>
<li>结构类型（值可在分割为若干成分的数据类型）：结构体</li>
</ol>
<p>抽象数据类型（adt）：是抽象数据组织及与之相关的操作。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>​    <strong>程序=数据结构+算法：</strong>数据结构是把现实世界的问题信息化，将信息存入计算机，同时                                        还要实现对数据结构的基本操作。算法是处理这些信息以解决实                                        际问题。</p>
<h3 id="算法的特性："><a href="#算法的特性：" class="headerlink" title="算法的特性："></a>算法的特性：</h3><ol>
<li>有穷性：一个算法必须在执行有穷步之后结束，且每一步都在有穷时间内完成。（算法                <strong>有穷</strong>程序可<strong>无穷</strong>）</li>
<li>确定性：对于相同的输入只能有相同输出。</li>
<li>可行性：算法中描述的操作可以通过已经实现地基本运算执行有限次来实现。</li>
<li>输入：一个算法中有0个或多个输入，输入来自某特定的对象集合。</li>
<li>输出：一个算法有一个或多个输出。输入输出有某种特定关系的量。</li>
</ol>
<h3 id="好算法的特性："><a href="#好算法的特性：" class="headerlink" title="好算法的特性："></a>好算法的特性：</h3><ul>
<li>正确性：算法能够正确的解决求解问题。</li>
<li>可读性：良好的可读性帮助人们理解。</li>
<li>健壮性：输入非法数据时算法能适当的做出反应或进行处理，不会产生莫名结果。</li>
<li>高效率与低存储需求：执行速度快<strong>时间复杂度低</strong>，不废内存<strong>空间复杂度</strong>。</li>
</ul>
<h3 id="算法的效率度量："><a href="#算法的效率度量：" class="headerlink" title="算法的效率度量："></a>算法的效率度量：</h3><ol>
<li><p>时间复杂度（算法时间开销）：随问题n的增大算法执行的时间的增长率和f(n)的增长率相同</p>
<p>让算法先运行，<strong>事后统计</strong>。问题：</p>
<ul>
<li>和机器的性能有关，超级计算机和单片机</li>
<li>和编程语言有关，越高级的语言执行效率越低</li>
<li>和编译程序产生地机器指令质量有关</li>
<li>有些算法是不能事后统计的如导弹控制算法</li>
</ul>
<p>排除算法本身无关的外界因素事前估计：</p>
<p>事前预估算法时间开销（时间time）T（n）与问题规模n的关系：</p>
<p>简单代码可以一行一行的数和计算。</p>
<p>忽略表达式的某些部分：去掉低阶部分只保留高阶部分，系数化1: “T(n)=O(高阶)”</p>
<ul>
<li><p>加法规则：T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))</p>
</li>
<li><p>乘法规则：T(n)=T1(n)×T2(n)=O(f(n))×O(g(n))=O(f(n)×g(n))</p>
</li>
<li><p>常见算法复杂度排序：O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlogn)&lt;O(n方)&lt;O(n立方)&lt;O(2的n次方)&lt;O(n阶乘)&lt;O(n的n次方)   <strong>魔法：</strong>常对幂指阶（上升)</p>
<p><img src="/2021/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/3.jpg"></p>
</li>
</ul>
<p>好几千行代码的处理（只需考虑最深层循环）：</p>
<ul>
<li><p>顺序执行的代码只会影响常数项，可以忽略（只关注循环）</p>
</li>
<li><p>只需调循环中的一个基本操作分析他的执行次数与n的关系即可</p>
</li>
<li><p>嵌套循环为n的几次嵌套次方：多层嵌套循环只需关注最深层循环循环了几次</p>
</li>
<li><p>最好时间复杂度：算法在最好情况下的时间复杂度，算法尽可能的达到最小值</p>
</li>
<li><p>最坏时间复杂度：算法在最坏情况下的时间复杂度，算法尽可能的达到最大值</p>
</li>
<li><p>平均时间复杂度：指算法在所有可能的情况下，按照输入势力以等概率出现时，</p>
<p>​                                算法计算量的加权平均值</p>
</li>
</ul>
<p>在计算算法时间复杂度时一般考虑最坏和平均复杂度</p>
</li>
<li><p>算法的空间复杂度：（解决空间开销与问题规模n之间的关系）</p>
<ul>
<li> 算法的空间复杂度：（与时间复杂度表示法类似也是O表示法保留最高阶数）</li>
</ul>
<p>  S(n)=O(f(n))  :S表示为“Space”</p>
<p>当S(n)=O(1)表示算法原地工作，算法所需内存空间为常量，算法所需空间与问题n的规模无关</p>
<p>通过定义的变量来计算空间复杂度，还有递归调用函数调用也需要计算空间</p>
<p>魔法：空间复杂度=递归调用的深度</p>
</li>
</ol>
<p>​        </p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="python学习之函数" class="lazyload">
                    <h1>python学习之函数</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月24日</a>
            <a><i class="nexmoefont icon-areachart"></i>3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 13 分钟</a>
        </div>

        <article>
            
                <h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>函数：完成特定功能的一个语句组，通过调用函数名来完成语句组的功能，可以反馈结果，提供不           同的参数实现对不同数据的处理。</p>
<p>自定义函数由用户自己编写，系统自带函数有python中内嵌的函数和标准库函数</p>
<p>使用函数的目的：降低编程难度，代码重用。</p>
<p>函数定义语句：</p>
<ol>
<li>函数关键字：函数以关键字def开头，后接函数名和圆括号()</li>
<li>函数名：必循遵循标识符的命名规则，最好有意义增加可读性</li>
<li>参数：必须放在圆括号中间，成为形式参数（形参），形参是可选的，可以有一个也可以有多个，多个参数间用‘，’分隔</li>
<li>函数说明：函数第一行的语句可以选择性地使用文档字符串，用于存放函数说明</li>
<li>函数内容：以冒号起始并且缩进</li>
<li>返回值：使用“return [表达式]”结束函数，返回一个值给调用方，若没有renturn返回值则默认返回None，当函数返回多个值时其本质是把这些值作为一个元组返回。</li>
<li>函数体：当函数体为pass语句，表示什么工作也不做，如抽象类中的抽象函数</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">def 函数名([参数1,参数2,...]):<br>	&quot;&quot;&quot;函数说明&quot;&quot;&quot;<br>	函数体<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/16.jpg" alt="以sum函数定义为例" class="lazyload"></p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myHello</span>():</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello，everone！&quot;</span><br></code></pre></td></tr></table></figure>

<p>函数有自己的成员，也可以为函数动态增减删除成员，在函数外部删除函数内部定义成员是无效的。</p>
<h1 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h1><p>函数调用时需要指出函数名称，并传入相应的函数调用时传入的参数称实参，默认情况下传入的实参必须等于定义时形参个数，顺序一制</p>
<p>函数调用顺序：</p>
<ol>
<li>执行函数调用前语句</li>
<li>执行函数调用，运行被调用函数内语句，并返回结果</li>
<li>执行函数调用后的语句</li>
</ol>
<p>函数调用的两种方法：</p>
<ol>
<li>调用函数传入实参</li>
<li>把函数对象赋给变量</li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/17.jpg" alt="以sum函数调用为例" class="lazyload"></p>
<h2 id="定义一个求梯形面积函数并调用"><a href="#定义一个求梯形面积函数并调用" class="headerlink" title="定义一个求梯形面积函数并调用"></a>定义一个求梯形面积函数并调用</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#求梯形面积</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">echelonArra</span>(<span class="hljs-params">top,bottom,height</span>):</span><br>    area=<span class="hljs-number">1</span> / <span class="hljs-number">2</span> * (top+bottom) *height<br>    <span class="hljs-keyword">return</span> area<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t=<span class="hljs-number">3.6</span>;b=<span class="hljs-number">6.2</span>;h=<span class="hljs-number">4.5</span><br>    area1=echelonArra(t,b,h)   <span class="hljs-comment">#第一种调用</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;area1=&quot;</span>,area1)<br>    area2=echelonArra<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;area2=&quot;</span>,area2(t,b,h))  <span class="hljs-comment">#第二种调用</span><br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/1.jpg" alt="结果" class="lazyload"></p>
<h1 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h1><p>python中的对象分为不可变对象（数字、字符串、元组）和可变对象（列表、字典、集合）</p>
<ol>
<li>实参为不可变对象，函数调用时将实参的值复制一份给形参，在函数调用中修改形参时不会影响函数外面的实参</li>
<li>实参为可变对象，函数调用时将实参引用复制给形参，在函数调用中修改形参时会影响函数外面的实参</li>
</ol>
<p>实参为不可变对象调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Swap</span>(<span class="hljs-params">x,y</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;交换前:x=&#123;&#125;,y=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x,y))<br>    x,y=y,x<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;交换后:x=&#123;&#125;,y=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x,y))<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>     a=<span class="hljs-number">6</span>;b=<span class="hljs-number">5</span><br>    Swap(a,b)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a=&#123;&#125;,b=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a,b))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/2.jpg"></p>
<p>实参为可变对象调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">changeList</span>(<span class="hljs-params">myList</span>):</span><br>    myList.append(<span class="hljs-number">4</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>      <span class="hljs-built_in">list</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用前list:&quot;</span>,<span class="hljs-built_in">list</span>)<br>    changeList(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用后list:&quot;</span>,<span class="hljs-built_in">list</span>)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/3.jpg"></p>
<h1 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h1><h2 id="必须参数"><a href="#必须参数" class="headerlink" title="必须参数"></a>必须参数</h2><p>要求调用时传入的实参个数、顺序和函数定义时形参的个数、顺序完全一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAdd</span>(<span class="hljs-params">x,y,z</span>):</span><br>    <span class="hljs-keyword">return</span> x+y+z<br> a=<span class="hljs-number">1</span>;b=<span class="hljs-number">2</span>;c=<span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结果：&quot;</span>,myAdd(a,b,c))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/4.jpg"></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>在函数调用时使用形参作为关键字来确定传入的参数值，允许函数调用时实参的顺序与函数定义时形参的顺序不一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stuInfo</span>(<span class="hljs-params">sno,sname</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;学号：&quot;</span>+sno+<span class="hljs-string">&quot;\n&quot;</span>+<span class="hljs-string">&quot;姓名：&quot;</span>+sname<br>  <br><span class="hljs-built_in">print</span>(stuInfo(sname=<span class="hljs-string">&quot;假的&quot;</span>,sno=<span class="hljs-string">&quot;66666&quot;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/5.jpg"></p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>调用函数时，如果没有传递实参，则会使用函数定义时赋予的参数的默认值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stuInfo1</span>(<span class="hljs-params">sno,sname,age=<span class="hljs-number">18</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;学号：&quot;</span>+sno+<span class="hljs-string">&quot;\n&quot;</span>+<span class="hljs-string">&quot;姓名：&quot;</span>+sname+<span class="hljs-string">&quot;\n&quot;</span>+<span class="hljs-built_in">str</span>(age)<br>    <br><span class="hljs-built_in">print</span>(stuInfo1(sname=<span class="hljs-string">&quot;假的&quot;</span>,sno=<span class="hljs-string">&quot;66666&quot;</span>))<br><span class="hljs-built_in">print</span>(stuInfo1(sname=<span class="hljs-string">&quot;假的&quot;</span>,sno=<span class="hljs-string">&quot;66666&quot;</span>,age=<span class="hljs-number">25</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/6.jpg"></p>
<h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>在实际使用中有可能需要一个函数能处理比当初声明时更多的参数，这种参数成为不定长参数</p>
<p>两种形式：</p>
<ul>
<li>*args:将接受的多个参数放在一个元组中</li>
<li>**args：将显示赋值的多个参数放入字典中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addFunc</span>(<span class="hljs-params">x,y,*args</span>):</span><br>    res=x+y<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> args:<br>        res +=k<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">**args</span>):</span><br>    <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> args.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(key,value))<br>        <br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用结果：&quot;</span>,addFunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>))<br>    func(新发明<span class="hljs-number">1</span>=<span class="hljs-string">&quot;高铁&quot;</span>,新发明<span class="hljs-number">2</span>=<span class="hljs-string">&quot;扫码支付&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/7.jpg"></p>
<h1 id="参数传递的序列解包"><a href="#参数传递的序列解包" class="headerlink" title="参数传递的序列解包"></a>参数传递的序列解包</h1><p>参数传递的序列解包针对的是实参，有*或**两种形式，加了后会将列表、元组、字典等迭代对象中的元素分别传递给形参中的多个变量</p>
<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/8.jpg"></p>
<p>将列表、元组、字典中的值分别迭代取出赋值给形参</p>
<h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><h2 id="1、匿名函数"><a href="#1、匿名函数" class="headerlink" title="1、匿名函数"></a>1、匿名函数</h2><p>​            匿名函数是指没有函数名的简单函数，只可以包含一个表达式，不允许包含其他复杂语句，表达式的结果就是函数的返回值</p>
<p>​    一般格式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">lambda [arg1[,arg2,...,argn]]:expression<br></code></pre></td></tr></table></figure>

<p>arg1,arg2,…:形参，可以没有，可以有一个或多个</p>
<p>expression：表达式</p>
<p>默认情况下调用匿名函数时传入实参个数与顺序同样要和匿名函数定义时形参个数顺序一致</p>
<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/9.jpg"></p>
<p>map()会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p>
<h2 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h2><p>​        如果一个函数在函数体中直接或间接的调用自身，那么这个函数就是递归函数，在执行的过程中可能会返回以再次调用该函数</p>
<p>​        函数a调用函数a自身为直接递归，函数a调用b，函数b在函数体中调用a则称简介递归</p>
<ul>
<li><p>​    递归函数求前n项的和：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs pytho">#递归求前n项的和<br>def fac(n):<br>    if n==1:<br>        return 1<br>    else:<br>        return fac(n-1)+n<br> if __name__ == &#x27;__main__&#x27;:<br> 	    print(&quot;前&#123;&#125;项的和为：&#123;&#125;&quot;.format(9,fac(9)))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/10.jpg"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">在递归时需要注意的两点：<br>1、递归函数就是在函数里调用自身<br>2、递归函数必须有一个明确的递归结束条件，称递归出口，否则造成死循环<br>3、前n-1项的和再加第n项，当n=1时为递归出口返回一<br></code></pre></td></tr></table></figure></li>
<li><p>使用递归求斐波那契数列前20项和</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#递归求斐波那契数列20项的和</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n==<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib(n-<span class="hljs-number">1</span>)+fib(n-<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	 <span class="hljs-comment">#求前20项：</span><br>    <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">21</span>):<br>        <span class="hljs-built_in">sum</span>=<span class="hljs-built_in">sum</span>+fib(<span class="hljs-number">20</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;前20项的和为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>))<br><br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/11.jpg"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">递归函数的优点：<br>1、递归函数使代码看起来更整洁优雅<br>2、可以用递归将复杂任务分解成更简单的子问题<br>3、使用递归比使用一些嵌套迭代更容易<br>递归函数缺点：<br>1、递归逻辑很难调试跟进<br>2、递归调用的代价高效率低，占用了大量的内存和时间<br>递归层数太多时不适合使用递归函数完成程序<br></code></pre></td></tr></table></figure>

<h2 id="3、嵌套函数"><a href="#3、嵌套函数" class="headerlink" title="3、嵌套函数"></a>3、嵌套函数</h2><p>​    嵌套函数是指在一个函数（外函数）中定义了另一个函数（内函数），称为内函数，嵌套函数中的内函数只能在外函数中调用，不能在外函数外面直接调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#嵌套函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outfunc</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">infunc</span>():</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是内函数&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是外函数&quot;</span>)<br>    infunc()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outerFunc</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">innerFunc</span>(<span class="hljs-params">y</span>):</span><br>        <span class="hljs-keyword">return</span> x+y;<br>    <span class="hljs-keyword">return</span> innerFunc   <span class="hljs-comment">#调用内函数</span><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	outfunc()<br>  	 <span class="hljs-comment"># infunc() #此句报红内函数在外部不可见出现语法错误</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方法一调用结果：&quot;</span>,outerFunc(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>))  <span class="hljs-comment">#调用时参数从最外层开始传递（最外层层参数）（内层参数）</span><br>    wai=outerFunc(<span class="hljs-number">3</span>)                        <span class="hljs-comment">#调用外函数，传递外函数参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方法二调用结果&quot;</span>,wai(<span class="hljs-number">4</span>))             <span class="hljs-comment">#间接调用内函数传递参数</span><br></code></pre></td></tr></table></figure>

<img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/12.jpg" style="zoom: 100%;">

<h2 id="4、装饰器"><a href="#4、装饰器" class="headerlink" title="4、装饰器"></a>4、装饰器</h2><p>​        装饰器是python中的一个比较特殊的功能，是用来包装函数的函数，装饰器可以是程序代码更简洁</p>
<p>使用的情况：</p>
<ul>
<li>将多个函数中的重复代码拿出来整理成一个装饰器，对每个函数使用装饰器，从而实现代码的重用</li>
<li>对多个函数的共同功能进行处理</li>
</ul>
<p>定义装饰器的一般格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>	<span class="hljs-keyword">pass</span><br><span class="hljs-meta">@decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br>	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>其中decorator为装饰器。@decorator为函数装饰器的修饰符。func为装饰器的函数对象参数，装饰器可以返回一个值、一个函数、一个装饰器或其他对象</p>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am in deco.&quot;</span>)<br>    func()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;deco return value.&quot;</span><br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funca</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am in func!&quot;</span>)<br><span class="hljs-built_in">print</span>(funca)<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/13.jpg"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">执行原理：<br>1、装饰器deco（）的参数为一个函数对象func<br>2、在函数前使用@deco修饰相当于将函数对象func作为参数调用装饰器deco（func）<br>3、func的值为调用装饰器deco（func）返回的结果<br></code></pre></td></tr></table></figure>

<p>使用装饰器修改网页文本格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deco</span>(<span class="hljs-params">f</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify_text</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;string&gt;&quot;</span>+f(<span class="hljs-built_in">str</span>)+<span class="hljs-string">&quot;&lt;/string&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> modify_text<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">texfun</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(texfun(<span class="hljs-string">&quot;text&quot;</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/14.jpg"></p>
<h2 id="5、带参数的装饰器"><a href="#5、带参数的装饰器" class="headerlink" title="5、带参数的装饰器"></a>5、带参数的装饰器</h2><p>​        装饰器除了默认函数对象参数还可以定义带参数的装饰器，带来更多的灵活性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DECO</span>(<span class="hljs-params">args</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deco</span>(<span class="hljs-params">func</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call_func</span>(<span class="hljs-params">x,y</span>):</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d %s %d=&quot;</span>%(x,args,y),end=<span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">return</span> func(x,y)<br>        <span class="hljs-keyword">return</span> call_func<br>    <span class="hljs-keyword">return</span> deco<br><br><span class="hljs-meta">@DECO(<span class="hljs-params"><span class="hljs-string">&#x27;&amp;&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">andfunc</span>(<span class="hljs-params">x,y</span>):</span><br>    <span class="hljs-keyword">return</span> x&amp;y<br><br><span class="hljs-meta">@DECO(<span class="hljs-params"><span class="hljs-string">&#x27;|&#x27;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">orfunc</span>(<span class="hljs-params">x,y</span>):</span><br>    <span class="hljs-keyword">return</span> x|y<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(andfunc(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br>    <span class="hljs-built_in">print</span>(orfunc(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/24/python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/15.jpg"></p>
<p>若一个函数有多个装饰器装饰，则称为多重装饰器，多重装饰器的执行顺序是：先执行后面的装饰器，在执行前面的装饰器。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>python中不同位置定义的变量决定了这个变量的访问权限和作用范围：</p>
<ul>
<li>局部变量和局部作用域L(Local)：包含在def关键字定义的语句块中即函数中定义的变量，局部变量在函数结束就消失了，调用时创建新的，结束时消失</li>
<li>全局变量和全局作用域G（Global）：在模块的函数外定义的变量，在模块顶层声明的变量具有全局作用域，从外部看全局变量是模块对象的属性，全局作用域的作用仅限于单个模块文件内</li>
<li>闭包变量和闭包作用域E（Enclosing）：定义在嵌套函数的外函数内、内函数外的变量，闭包变量作用域为嵌套函数内定义它的位置开始的整个函数内</li>
<li>内建变量和内建作用域B（Built-in）：系统内固定模块里定义的变量一般预定义在内建模块内的变量</li>
</ul>
<p>按照L→E→G→B的顺序查找，局部变量和全局变量使用的多，内建变量使用的最少</p>
<p>局部变量只能在其声明的函数内使用，全局变量在整个模块内访问</p>
<p>修改变量作用域的关键字：</p>
<ol>
<li>global：加上global即可将变量设置为全局变量</li>
<li>nonlocal：加上即可将嵌套函数中的内函数局部变量变为闭包变量</li>
</ol>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="python语言基础学习(二)" class="lazyload">
                    <h1>python语言基础学习(二)</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月22日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 11 分钟</a>
        </div>

        <article>
            
                <h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/2.jpg" alt="顺序向下写" class="lazyload"></p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><ul>
<li><p>单分支</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">if 表达式:<br>	语句块<br></code></pre></td></tr></table></figure></li>
<li><p>二分支</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">if 表达式:<br>	语句块1<br>else:<br>	语句块2<br></code></pre></td></tr></table></figure></li>
<li><p>多分支</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">if 表达式1: <br>    语句块1	<br>elif 表达式2: <br>    语句块2<br>…<br>[else:<br>    语句块n+1]<br></code></pre></td></tr></table></figure>

<h3 id="练习：使用if多分支语句实现简单的算术运算，•支持-、-、-、-运算："><a href="#练习：使用if多分支语句实现简单的算术运算，•支持-、-、-、-运算：" class="headerlink" title="练习：使用if多分支语句实现简单的算术运算，•支持+、-、*、/运算："></a>练习：使用if多分支语句实现简单的算术运算，•支持+、-、*、/运算：</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    input_op=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入运算：（操作数何操作符之间用空格分隔）&quot;</span>)<br>    x,op,y=input_op.split()<br>    <span class="hljs-keyword">if</span> op==<span class="hljs-string">&#x27;+&#x27;</span>:<br>        z=<span class="hljs-built_in">float</span>(x)+<span class="hljs-built_in">float</span>(y)<br>    <span class="hljs-keyword">elif</span> op==<span class="hljs-string">&#x27;-&#x27;</span>:<br>        z=<span class="hljs-built_in">float</span>(x)-<span class="hljs-built_in">float</span>(y)<br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;*&#x27;</span>:<br>        z=<span class="hljs-built_in">float</span>(x)*<span class="hljs-built_in">float</span>(y)<br>    <span class="hljs-keyword">elif</span> op == <span class="hljs-string">&#x27;/&#x27;</span>:<br>        <span class="hljs-keyword">if</span> y==<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;分母不能为零输入错误！！！&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            z=<span class="hljs-built_in">float</span>(x)/<span class="hljs-built_in">float</span>(y);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x,op,y,z))<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/1.jpg" alt="结果" class="lazyload"></p>
</li>
</ul>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">while 表达式:<br>       语句块<br>[else:<br>        else子句语句块]<br></code></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">for 变量 in 序列或迭代对象：<br>	语句块<br>[else:<br>  	else子句语句块]<br></code></pre></td></tr></table></figure>

<h3 id="三个在循环语句中使用的关键字："><a href="#三个在循环语句中使用的关键字：" class="headerlink" title="三个在循环语句中使用的关键字："></a>三个在循环语句中使用的关键字：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">break语句：退出循环<br>continue语句：跳过该次循环<br>pass：空语句（不做任何处理）<br></code></pre></td></tr></table></figure>

<h4 id="练习-使用while语句计算1-100的和（for循环时可以使用range函数）："><a href="#练习-使用while语句计算1-100的和（for循环时可以使用range函数）：" class="headerlink" title="练习  使用while语句计算1~100的和（for循环时可以使用range函数）："></a>练习  使用while语句计算1~100的和（for循环时可以使用range函数）：</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  	i=<span class="hljs-number">0</span><br>    s=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i&lt;=<span class="hljs-number">100</span>:<br>        s=s+i<br>        i=i+<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;while循环：&quot;</span>,s)<br>    s1=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>):<br>        s1=s1+a<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;for循环：&quot;</span>,s1)<br></code></pre></td></tr></table></figure>



<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/3.jpg" alt="结果" class="lazyload"></p>
<h4 id="练习-输出九九乘法表"><a href="#练习-输出九九乘法表" class="headerlink" title="练习 输出九九乘法表:"></a>练习 输出九九乘法表:</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span>(i*a&gt;=<span class="hljs-number">10</span>):<br>                <span class="hljs-built_in">str</span>=<span class="hljs-string">&quot; &quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;  &quot;</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d*%d=%d&quot;</span>%(a,i,i*a),end=<span class="hljs-built_in">str</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/4.jpg" alt="结果" class="lazyload"></p>
<h1 id="组合数据"><a href="#组合数据" class="headerlink" title="组合数据"></a>组合数据</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul>
<li><p>创建列表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">1、使用[ ]运算符创建列表：<br>    list1 = []             		                 	<br>    list2 = [1.25,21.06,0.3,4.7,58.1]        	<br>    list3 = [&quot;石油&quot;,&quot;汽车&quot;,&quot;建筑&quot;,&quot;IT&quot;]         	<br>    list4 = [&#x27;Alice’, 18, &#x27;Beth’, 19]<br>2、使用list()函数创建列表<br>    &gt;&gt;&gt;list1 = list()                           	<br>    &gt;&gt;&gt;list((&quot;李白&quot;,&quot;杜甫&quot;,&quot;白居易&quot;))     		<br>    [&#x27;李白&#x27;, &#x27;杜甫&#x27;, &#x27;白居易&#x27;]<br>    &gt;&gt;&gt; list(&quot;素质重于能力重于学历&quot;)            	<br>    [&#x27;素&#x27;, &#x27;质&#x27;, &#x27;重&#x27;, &#x27;于&#x27;, &#x27;能&#x27;, &#x27;力&#x27;, &#x27;重&#x27;, &#x27;于&#x27;, &#x27;学&#x27;, &#x27;历&#x27;]<br>    &gt;&gt;&gt; list(range(5))          				<br>    [0, 1, 2, 3, 4]<br><br></code></pre></td></tr></table></figure></li>
<li><p>访问列表</p>
<p>1、索引访问</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/5.jpg" alt="索引访问" class="lazyload"></p>
</li>
</ul>
<p>​       2、切片访问</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/6.jpg" alt="切片访问" class="lazyload">    </p>
<ul>
<li><p>遍历列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">carList = [<span class="hljs-string">&quot;奔驰&quot;</span>, <span class="hljs-string">&quot;大众&quot;</span>, <span class="hljs-string">&quot;福特&quot;</span>, <span class="hljs-string">&quot;宝马&quot;</span>, <span class="hljs-string">&quot;奥迪&quot;</span>, <span class="hljs-string">&quot;雪佛兰&quot;</span>]<br><span class="hljs-keyword">for</span> car <span class="hljs-keyword">in</span> carList:<br>    <span class="hljs-built_in">print</span>(car,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/7.jpg" alt="结果" class="lazyload"></p>
</li>
<li><p>添加列表元素</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">添加方法如下：<br>(1) list.append(newItem)<br>(2) list.insert(index, newItem)<br>(3) list.extend(seq)<br>(4) list[len(list):] = newList<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/8.jpg" alt="调用" class="lazyload"></p>
</li>
<li><p>修改列表元素</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/9.jpg" alt="修改" class="lazyload"></p>
</li>
<li><p>删除列表元素</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">(1) del list[index]：删除索引为index的元素。<br>(2) list.pop()：删除列表末尾的元素。<br>(3) list.pop(index)：删除索引为index的元素。<br>(4) list.remove(item)：删除列表元素item。<br>(5) list.clear()：删除列表中所有元素。<br>(6) list[::] = []：对指定范围的列表元素进行删除。<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/10.jpg" alt="尝试使用删除" class="lazyload"></p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/11.jpg" alt="尝试2" class="lazyload"></p>
<ul>
<li><p>复制列表</p>
<p>1、直接复制 list_copy = list1</p>
<p>2、浅拷贝 使用list.copy（只对第一层实现深拷贝）</p>
<p>3、深拷贝 使用copy模块，copy.deepcopy()</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<span class="hljs-number">280</span>]<br>    c=a.copy()<br>    b=copy.deepcopy(a)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">0</span>]))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">0</span>]))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c[<span class="hljs-number">0</span>]))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;——&#x27;</span> *<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a[<span class="hljs-number">2</span>]))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b[<span class="hljs-number">2</span>]))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c[<span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/12.jpg" alt="拷贝分析" class="lazyload"></p>
<ul>
<li>删除列表</li>
</ul>
<p><img src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/13.jpg"></p>
<ul>
<li>列表运算</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">+、*、in、not in<br>关系运算符：规则是从两个列表的第1个元素开始比较，如果比较有结果则结束；否则继续比较两个列表后面对应位置的元素。<br>注：对比字符串运算（一致）<br></code></pre></td></tr></table></figure>

<ul>
<li><p>列表统计</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">(1) len(list)：返回列表list中的元素个数。<br>(2) max(list)：返回列表list中元素的最大值。<br>(3) min(list)：返回列表list中元素的最小值。<br>(4) sum(list)：返回列表list中所有元素的和。<br>(5) list.count(key)：返回关键字key在列表中的出现次数。<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/14.jpg"></p>
</li>
<li><p>列表查找与排序</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">1、查找函数<br>List.index(key)<br>2、排序函数<br>list.sort()：对列表list中的元素按照一定的规则排序。<br>list.reverse()：对列表list中的元素按照一定的规则反向排序。<br>sorted(list)：对列表list 中的元素进行临时排序，返回副本。<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/15.jpg"></p>
</li>
</ul>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（Tuple)是写在（）之间用逗号隔开的元素集合，元组创建后其中的元素不能修改</p>
<ul>
<li><p>元组创建</p>
<p>使用（）运算符创建元组</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">tuple1=() <span class="hljs-params">#</span>创建空元组<br>tuple2=(1,8,24,65,125)<span class="hljs-params">#</span>元素为数字<br>tuple3=(&quot;计算机&quot;,&quot;生物信息&quot;)<span class="hljs-params">#</span>元素为字符串<br>tuple4=(&quot;华为&quot;,&quot;5564654&quot;,666)<span class="hljs-params">#</span>元素为数字和字符串混合<br></code></pre></td></tr></table></figure>

<p>使用tuple（）函数创建元组：tuple（sequence）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span>(<span class="hljs-string">&quot;理想是人生的太阳&quot;</span>)<br>(<span class="hljs-string">&#x27;理&#x27;</span>, <span class="hljs-string">&#x27;想&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;人&#x27;</span>, <span class="hljs-string">&#x27;生&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;太&#x27;</span>, <span class="hljs-string">&#x27;阳&#x27;</span>)<br><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>))<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">tuple</span>([<span class="hljs-string">&quot;莎士比亚&quot;</span>,<span class="hljs-string">&quot;托尔斯泰&quot;</span>,<span class="hljs-string">&quot;但丁&quot;</span>,<span class="hljs-string">&quot;雨果&quot;</span>,<span class="hljs-string">&quot;歌德&quot;</span>])<br>(<span class="hljs-string">&#x27;莎士比亚&#x27;</span>, <span class="hljs-string">&#x27;托尔斯泰&#x27;</span>, <span class="hljs-string">&#x27;但丁&#x27;</span>, <span class="hljs-string">&#x27;雨果&#x27;</span>, <span class="hljs-string">&#x27;歌德&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>元组访问</p>
<ol>
<li><p>通过元组名访问元组</p>
</li>
<li><p>通过tuple[index]访问指定索引为index的元组元素</p>
</li>
<li><p>元组切片（start：end：step）</p>
</li>
<li><p>遍历元组：for 变量 in 元组名</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/16.jpg" alt="测试" class="lazyload"></p>
</li>
</ol>
</li>
<li><p>元组复制和删除</p>
<ol>
<li><p>支持赋值语句直接复制</p>
</li>
<li><p>del删除元组</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/17.jpg" alt="测试" class="lazyload"></p>
</li>
</ol>
</li>
<li><p>元组运算</p>
<p>元组运算包括+、in/not in 及关系运算符等，使用方法和列表中类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">wanyue_tuple=(<span class="hljs-string">&quot;柳永&quot;</span>,<span class="hljs-string">&quot;晏殊&quot;</span>)<br>   haofang_tuple=(<span class="hljs-string">&quot;陆游&quot;</span>,<span class="hljs-string">&quot;苏轼&quot;</span>)<br>   ci_author_tuple=wanyue_tuple+haofang_tuple<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;宋朝词人&quot;</span>,ci_author_tuple)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;李清照是宋朝词人吗?&quot;</span>,<span class="hljs-string">&quot;李清照&quot;</span> <span class="hljs-keyword">in</span> ci_author_tuple)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;岳飞 出现三次的元组:&quot;</span>,(<span class="hljs-string">&quot;岳飞&quot;</span>)*<span class="hljs-number">3</span>)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wanyue_tuple &lt;ci_author_tuple?&quot;</span>,wanyue_tuple&lt;ci_author_tuple)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/18.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>元组统计</p>
<ol>
<li><p>max()</p>
</li>
<li><p>min()</p>
</li>
<li><p>sum()</p>
</li>
<li><p>count()</p>
</li>
<li><p>len()</p>
<p>等和列表操作类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pelltuple=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">29</span>,<span class="hljs-number">70</span>,<span class="hljs-number">169</span>,<span class="hljs-number">408</span>,<span class="hljs-number">985</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最大值:&quot;</span>,<span class="hljs-built_in">max</span>(pelltuple))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最小值:&quot;</span>,<span class="hljs-built_in">min</span>(pelltuple))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有元素的和:&quot;</span>,<span class="hljs-built_in">sum</span>(pelltuple))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;元素%d在元组中出现的次数:%d.次&quot;</span>%(<span class="hljs-number">5</span>,pelltuple.count(<span class="hljs-number">5</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;元组中的元素个数:%d个.&quot;</span>%(<span class="hljs-built_in">len</span>(pelltuple)))<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/19.jpg" alt="测试" class="lazyload"></p>
<h2 id="字典："><a href="#字典：" class="headerlink" title="字典："></a>字典：</h2><p>用{}标识创建，字典是一个无序的“键（key）：值（value)”对集合，键（key）必须使用不可便类型，如字符串、数字等，值（value)可以是简单数据或组合数据多种不同类型，在同一个字典中键（key）必须是唯一的，值可以不唯一</p>
<ul>
<li><p>字典创建</p>
<p>使用{}运算符创建字典</p>
<p>使用dict()函数创建：</p>
<p>（1）dict（**kwarg):以关键字创建字典。**kwarg为关键字</p>
<p>（2）dict（mapping，**kwarg):以映射方式构造字典，mapping为元素的容器</p>
<p>（3）dict（iterable，**kwarg):以可迭代对象方式构造字典，iterable为可迭代对象</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/20.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>字典访问</p>
<p>通过字典名访问字典，通过“dict[key]”或”dict.get(key)”房屋指定元素</p>
<p>dict.itms():以列表形式返回字典中所有的“键/值”对，每个“键/值”对以元组的形式存在</p>
<p>dict.keys()：以列表的形式返回字典中的所有键</p>
<p>dict.values():以列表形式返回字典中所有的值</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/21.jpg" alt="访问" class="lazyload"></p>
<p>for循环遍历字典中所有元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>=&#123;<span class="hljs-string">&quot;猪肉&quot;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&quot;羊肉&quot;</span>:<span class="hljs-number">20</span>,<span class="hljs-string">&quot;牛肉&quot;</span>:<span class="hljs-number">30</span>&#125;<br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span>  <span class="hljs-built_in">dict</span>.items():<br>    <span class="hljs-built_in">print</span>(key,<span class="hljs-string">&#x27;/&#x27;</span>,value,end=<span class="hljs-string">&quot;       &quot;</span>)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/22.jpg" alt="测试" class="lazyload"></p>
<p>字典元素的添加、修改、删除</p>
<p>添加：</p>
<p>dict[key]=value  #key不存在</p>
<p>修改：</p>
<p>dict[key]=value #key已存在</p>
<p>删除：</p>
<p>del dict[key]：删除关键字为key的元素</p>
<p>dict.pop(key):删除关键字为key的元素</p>
<p>dict.popitem():随机删除字典中的元素</p>
<p>dict.clear():删除字典中所有元素</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/23.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>字典复制和删除</p>
<p>赋值语句进行复制：源改新改</p>
<p>copy函数：源改新不改</p>
<p>deepcopy模块进行复制</p>
<p>del语句进行字典删除</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/24.jpg" alt="测试" class="lazyload"></p>
<p>这里和列表的拷贝类似</p>
</li>
</ul>
<h2 id="集合（set）："><a href="#集合（set）：" class="headerlink" title="集合（set）："></a>集合（set）：</h2><p>在{}之间，用逗号分隔无序且不重复的元素集合，不可以为集合创建索引或执行切片（slice）操作</p>
<p>没有键（key）可以用来获取集合中元素的值。</p>
<ul>
<li><p>集合创建</p>
<p>python中可以使用{}运算符创建集合</p>
<p>set()函数创建集合,()可以传入字符串、列表、元组或range()函数的返回结果，使用list作为set函数参数可以将列表中的重复元素干掉</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/25.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>集合访问</p>
<p>使用集合名访问集合</p>
<p>for循环遍历集合中的元素</p>
<p>set.add(item)添加集合元素</p>
<p>set.update(item)更新修改集合元素</p>
<p>删除集合元素：</p>
<p>set.remove(item):删除指定元素item</p>
<p>set.discard(item):删除指定元素item</p>
<p>set.pop:随机删除集合中的元素</p>
<p>set.clear:清空集合列表</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/26.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>集合复制和删除</p>
<p>复制：</p>
<p>​        赋值语句复制</p>
<p>​        copy()函数赋值（浅复制）</p>
<p>​        deepcopy()模块赋值（深复制）</p>
<p>删除：</p>
<p>​        del语句删除</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/27.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>集合运算</p>
<p>(1) set1.union(set2) 或 set1 | set2：并集运算。</p>
<p>(2) set1.intersection(set2) 或 set1 &amp; set2：交集运算。</p>
<p>(3) set1. difference(set2) 或 set1 - set2：差集运算。</p>
<p>(4) set1. issubset(set2) 或 set1 &lt; set2：子集运算。</p>
<p>(5) item in set 或item not in set：成员运算。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/28.jpg" alt="测试" class="lazyload"></p>
</li>
<li><p>集合统计</p>
<p>max()函数、min()函数、sum()函数、len()函数</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/22/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C/29.jpg" alt="测试" class="lazyload"></p>
</li>
</ul>
<h2 id="嵌套组合数据"><a href="#嵌套组合数据" class="headerlink" title="嵌套组合数据"></a>嵌套组合数据</h2><p>​            当组合数据中的元素为组合数据时，称为嵌套组合数据如嵌套列表中的元素是：列表、元素、字典、集合等，嵌套字典中的元素是：列表、字典、元组、集合。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="/assets/background.gif" data-sizes="auto" alt="python语言基础学习" class="lazyload">
                    <h1>python语言基础学习</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年09月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>841 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="python中的数据类型："><a href="#python中的数据类型：" class="headerlink" title="python中的数据类型："></a>python中的数据类型：</h2><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="整形："><a href="#整形：" class="headerlink" title="整形："></a>整形：</h4><p>Python中的整形不限制大小：</p>
<ul>
<li><p>十进制 10                                       int() 其他类型转十进制整型</p>
</li>
<li><p>二进制    0b1010或0B1010            bin()其他类型转二进制</p>
</li>
<li><p>八进制    0O12                                oct()其他类型转八进制</p>
</li>
<li><p>十六进制    0xa                                hex()其他类型转十六进制</p>
</li>
</ul>
<p>​    练习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br> a=<span class="hljs-number">123</span><br> <span class="hljs-built_in">print</span>(a)<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;二进制:&quot;</span>,<span class="hljs-built_in">bin</span>(a))<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;八进制:&quot;</span>,<span class="hljs-built_in">oct</span>(a))<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;十六进制:&quot;</span>,<span class="hljs-built_in">hex</span>(a))<br></code></pre></td></tr></table></figure>

<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><p>十进制浮点数：1080.00        %f    (格式化输出符)</p>
</li>
<li><p> 科学计数法浮点数：1.08e3        %e    (格式化输出符)</p>
</li>
<li><p> python支持大约17位的精度和范围从-308到308的指数（双精度）</p>
</li>
<li><p> 不分单精度和双精度</p>
</li>
</ul>
<p>​    练习：将华氏温度转为摄氏温度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br> f=<span class="hljs-number">100.00</span><br> c=(f-<span class="hljs-number">32.00</span>)/<span class="hljs-number">1.8</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;摄氏度:%f&quot;</span>%c)<br></code></pre></td></tr></table></figure>

<p>​    浮点型的比较运算：</p>
<p>​    比较运算：浮点数可以直接比较大小 由于精度的原因执行以下代码时会输出else的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">0.2</span><br>b = <span class="hljs-number">0.1</span><br><span class="hljs-keyword">if</span>((a + b) == <span class="hljs-number">0.3</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(a + b) == 0.3&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(a + b) != 0.3&quot;</span>)<br><br></code></pre></td></tr></table></figure>

<h4 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h4><p>complex(实部, 虚部)</p>
<p>例：c1=1.2+5.3j为complex(1.2, 5.3)</p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>取值True、False，在python中0、空字符串表实False</p>
<h4 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/5.jpg"></p>
<p>练习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x=<span class="hljs-number">25</span><br>y=<span class="hljs-number">30</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(x))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(x))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(x))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">complex</span>(x))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">complex</span>(x, y))<br></code></pre></td></tr></table></figure>

<p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/8.jpg"></p>
<h4 id="常用数学函数："><a href="#常用数学函数：" class="headerlink" title="常用数学函数："></a>常用数学函数：</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/14.jpg"></p>
<h3 id="组合数据"><a href="#组合数据" class="headerlink" title="组合数据"></a>组合数据</h3><h4 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h4><ul>
<li><p>成对的单引号(‘)或双引号(“)括起来</p>
</li>
<li><p>如：”中国制造”，’Python’</p>
</li>
<li><p>成对的三引号(‘’’’’’)或(“‘)创建跨多行的字符串</p>
</li>
<li><p>也可以是多行注释</p>
</li>
</ul>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/9.jpg"></p>
<p>练习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    a=<span class="hljs-string">&#x27;success&#x27;</span><br>    <span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>:],a[:<span class="hljs-number">4</span>],a[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>],a[:])<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%9C.jpg" alt="结果" class="lazyload"></p>
<h4 id="字符串创建函数："><a href="#字符串创建函数：" class="headerlink" title="字符串创建函数："></a>字符串创建函数：</h4><ul>
<li><p>str()          转义</p>
</li>
<li><p>repr()        原样</p>
</li>
</ul>
<p>运行图：</p>
<p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/2.jpg"></p>
<h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/3.jpg"></p>
<p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/4.jpg"></p>
<p>​                    比较时判断的是字符串的编码大小</p>
<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/6.jpg"></p>
<p>字符串格式化输出方式：</p>
<ul>
<li>print(‘{0}, {1}.’.format(‘Hello’,’world’))</li>
<li>print(‘{}, I am {}.’.format(‘Hello’,’Python’))</li>
<li>print(‘{0} {1}, {1} is a new prgramming language.’.format(‘Hello’,’Python’))</li>
<li>print(“网站名：{name}, 地址 {url}”.format(name=”name”, url=”<a target="_blank" rel="noopener" href="http://www.xxxx.xx/&quot;">http://www.xxxx.xx/&quot;</a>))</li>
</ul>
<p>字典格式化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">site = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;http://www.xxxx.cn/&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="hljs-built_in">format</span>(**site))<br></code></pre></td></tr></table></figure>

<p>列表格式化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-string">&#x27;world&#x27;</span>,<span class="hljs-string">&#x27;python&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello &#123;names[0]&#125;, I am &#123;names[1]&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(names=<span class="hljs-built_in">list</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello &#123;0[0]&#125;, I am &#123;0[1]&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">list</span>))<br></code></pre></td></tr></table></figure>

<p>练习：判断输入的手机号码是否正确</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br> <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>):<br>    a = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入手机号：&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a)!=<span class="hljs-number">11</span>:<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;手机号长度不合法，请重新输入！&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> a.isdecimal():<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入正确!&quot;</span>)<br>         <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span>:<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入不正确！请重新输入！&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/15.jpg" alt="结果" class="lazyload"></p>
<h4 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/7.jpg"></p>
<h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><ul>
<li><p>常量：Python中没有专门定义常量的方式，通常使用大写变量名表示。其本质还是变量。</p>
</li>
<li><p>例：PI = 3.14</p>
</li>
<li><p>变量：</p>
<p>变量的值可以变，类型也可以变。</p>
<p>当用变量的时候，必须给这个变量赋值。</p>
<p>如果只声明一个变量而没有赋值，则Python认为这个变量没有定义。</p>
</li>
</ul>
<p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/10.jpg"></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/11.jpg"></p>
<p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/12.jpg"></p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><ul>
<li>内置函数(Built-In Functions，BIF)是Python的内置对象类型之一，封装在标准库模块_ <em>builtins</em> _中 如：input（），print（）</li>
</ul>
<h4 id="特殊内置函数"><a href="#特殊内置函数" class="headerlink" title="特殊内置函数"></a>特殊内置函数</h4><p><img src="/2021/09/13/python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/13.jpg"></p>
<h3 id="本次学习结束"><a href="#本次学习结束" class="headerlink" title="本次学习结束"></a>本次学习结束</h3>
            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
        <a class="extend prev" rel="prev" href="/tags/%E5%AD%A6%E4%B9%A0/"><i class="nexmoefont icon-left"></i></a><a class="page-number" href="/tags/%E5%AD%A6%E4%B9%A0/">1</a><span class="page-number current">2</span>
    </nav>
  
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1679977717833"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





</body>

</html>
